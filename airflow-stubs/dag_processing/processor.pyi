import logging
from _typeshed import Incomplete
from airflow import settings as settings
from airflow.api_internal.internal_api_call import InternalApiConfig as InternalApiConfig, internal_api_call as internal_api_call
from airflow.callbacks.callback_requests import CallbackRequest as CallbackRequest, DagCallbackRequest as DagCallbackRequest, SlaCallbackRequest as SlaCallbackRequest, TaskCallbackRequest as TaskCallbackRequest
from airflow.configuration import conf as conf
from airflow.exceptions import AirflowException as AirflowException, TaskNotFound as TaskNotFound
from airflow.listeners.listener import get_listener_manager as get_listener_manager
from airflow.models import SlaMiss as SlaMiss
from airflow.models.dag import DAG as DAG, DagModel as DagModel
from airflow.models.dagbag import DagBag as DagBag
from airflow.models.dagwarning import DagWarning as DagWarning, DagWarningType as DagWarningType
from airflow.models.errors import ParseImportError as ParseImportError
from airflow.models.operator import Operator as Operator
from airflow.models.serialized_dag import SerializedDagModel as SerializedDagModel
from airflow.models.taskinstance import TaskInstance as TaskInstance
from airflow.stats import Stats as Stats
from airflow.utils import timezone as timezone
from airflow.utils.email import get_email_address_list as get_email_address_list, send_email as send_email
from airflow.utils.file import iter_airflow_imports as iter_airflow_imports, might_contain_dag as might_contain_dag
from airflow.utils.log.logging_mixin import LoggingMixin as LoggingMixin, StreamLogWriter as StreamLogWriter, set_context as set_context
from airflow.utils.mixins import MultiprocessingStartMethodMixin as MultiprocessingStartMethodMixin
from airflow.utils.session import NEW_SESSION as NEW_SESSION, provide_session as provide_session
from airflow.utils.state import TaskInstanceState as TaskInstanceState
from dataclasses import dataclass
from datetime import datetime
from sqlalchemy.orm.session import Session as Session
from typing import Generator, Iterable

@dataclass
class _QueryCounter:
    queries_number: int = ...
    def inc(self) -> None: ...

def count_queries(session: Session) -> Generator[_QueryCounter, None, None]: ...

class DagFileProcessorProcess(LoggingMixin, MultiprocessingStartMethodMixin):
    class_creation_counter: int
    def __init__(self, file_path: str, pickle_dags: bool, dag_ids: list[str] | None, dag_directory: str, callback_requests: list[CallbackRequest]) -> None: ...
    @property
    def file_path(self) -> str: ...
    def start(self) -> None: ...
    def kill(self) -> None: ...
    def terminate(self, sigkill: bool = False) -> None: ...
    @property
    def pid(self) -> int: ...
    @property
    def exit_code(self) -> int | None: ...
    @property
    def done(self) -> bool: ...
    @property
    def result(self) -> tuple[int, int, int] | None: ...
    @property
    def start_time(self) -> datetime: ...
    @property
    def waitable_handle(self): ...
    def import_modules(self, file_path: str | Iterable[str]): ...

class DagFileProcessor(LoggingMixin):
    UNIT_TEST_MODE: bool
    dag_ids: Incomplete
    dag_warnings: set[tuple[str, str]]
    def __init__(self, dag_ids: list[str] | None, dag_directory: str, log: logging.Logger) -> None: ...
    @classmethod
    def manage_slas(cls, dag_folder, dag_id: str, session: Session = ...) -> None: ...
    @staticmethod
    def update_import_errors(file_last_changed: dict[str, datetime], import_errors: dict[str, str], processor_subdir: str | None, session: Session = ...) -> None: ...
    @classmethod
    def update_dag_warnings(cla, *, dagbag: DagBag) -> None: ...
    @classmethod
    def execute_callbacks(cls, dagbag: DagBag, callback_requests: list[CallbackRequest], unit_test_mode: bool, session: Session = ...) -> None: ...
    @classmethod
    def execute_callbacks_without_dag(cls, callback_requests: list[CallbackRequest], unit_test_mode: bool, session: Session = ...) -> None: ...
    def process_file(self, file_path: str, callback_requests: list[CallbackRequest], pickle_dags: bool = False, session: Session = ...) -> tuple[int, int, int]: ...
    @staticmethod
    def save_dag_to_db(dags: dict[str, DAG], dag_directory: str, pickle_dags: bool = False, session=...): ...
