import airflow.models.errors as errors
import airflow.utils.timezone as timezone
import flask_appbuilder.models.filters
import flask_appbuilder.models.sqla.filters
import flask_appbuilder.models.sqla.interface
import flask_babel.speaklater
import pygments.lexers.special
from _typeshed import Incomplete
from airflow.configuration import conf as conf
from airflow.exceptions import RemovedInAirflow3Warning as RemovedInAirflow3Warning
from airflow.models.dagrun import DagRun as DagRun
from airflow.models.dagwarning import DagWarning as DagWarning
from airflow.models.taskinstance import TI as TI, TaskInstance as TaskInstance
from airflow.utils.code_utils import get_python_source as get_python_source
from airflow.utils.helpers import alchemy_to_dict as alchemy_to_dict
from airflow.utils.json import WebEncoder as WebEncoder
from airflow.utils.sqlalchemy import tuple_in_condition as tuple_in_condition
from airflow.utils.state import State as State, TaskInstanceState as TaskInstanceState
from airflow.www.extensions.init_auth_manager import get_auth_manager as get_auth_manager
from airflow.www.forms import DateTimeWithTimezoneField as DateTimeWithTimezoneField
from airflow.www.widgets import AirflowDateTimePickerWidget as AirflowDateTimePickerWidget
from markupsafe import Markup
from typing import Any, Callable, ClassVar, Sequence

TYPE_CHECKING: bool
def datetime_to_string(value: DateTime | None) -> str | None: ...
def get_mapped_instances(task_instance, session): ...
def get_instance_with_map(task_instance, session): ...
def get_try_count(try_number: int, state: State): ...

priority: list
def get_mapped_summary(parent_instance, task_instances): ...
def get_dag_run_conf(dag_run_conf: Any) -> tuple[str | None, bool]: ...
def encode_dag_run(dag_run: DagRun | None) -> dict[str, Any] | None: ...
def check_import_errors(fileloc, session): ...
def check_dag_warnings(dag_id, session): ...
def get_sensitive_variables_fields(): ...
def should_hide_value_for_key(key_name): ...
def get_params(**kwargs): ...
def generate_pages(current_page, num_of_pages, search: Incomplete | None = ..., status: Incomplete | None = ..., tags: Incomplete | None = ..., window: int = ..., sorting_key: Incomplete | None = ..., sorting_direction: Incomplete | None = ...): ...
def epoch(dttm): ...
def make_cache_key(*args, **kwargs): ...
def task_instance_link(attr): ...
def state_token(state): ...
def state_f(attr): ...
def nobr_f(attr_name): ...
def datetime_f(attr_name): ...
def datetime_html(dttm: DateTime | None) -> str: ...
def json_f(attr_name): ...
def dag_link(attr): ...
def dag_run_link(attr): ...
def sorted_dag_runs(query: Select) -> Sequence[DagRun]: ...
def format_map_index(attr: dict) -> str: ...
def pygment_html_render(s, lexer: type[pygments.lexers.special.TextLexer] = ...): ...
def render(obj: Any, lexer: Lexer, handler: Callable[[Any], str] | None = ...): ...
def json_render(obj, lexer): ...
def wrapped_markdown(s, css_class: str = ...): ...
def get_attr_renderer(): ...
def get_chart_height(dag): ...

class UtcAwareFilterMixin:
    def apply(self, query, value): ...

class FilterIsNull(flask_appbuilder.models.filters.BaseFilter):
    name: ClassVar[flask_babel.speaklater.LazyString] = ...
    arg_name: ClassVar[str] = ...
    def apply(self, query, value): ...

class FilterIsNotNull(flask_appbuilder.models.filters.BaseFilter):
    name: ClassVar[flask_babel.speaklater.LazyString] = ...
    arg_name: ClassVar[str] = ...
    def apply(self, query, value): ...

class FilterGreaterOrEqual(flask_appbuilder.models.filters.BaseFilter):
    name: ClassVar[flask_babel.speaklater.LazyString] = ...
    arg_name: ClassVar[str] = ...
    def apply(self, query, value): ...

class FilterSmallerOrEqual(flask_appbuilder.models.filters.BaseFilter):
    name: ClassVar[flask_babel.speaklater.LazyString] = ...
    arg_name: ClassVar[str] = ...
    def apply(self, query, value): ...

class UtcAwareFilterSmallerOrEqual(UtcAwareFilterMixin, FilterSmallerOrEqual): ...
class UtcAwareFilterGreaterOrEqual(UtcAwareFilterMixin, FilterGreaterOrEqual): ...
class UtcAwareFilterEqual(UtcAwareFilterMixin, flask_appbuilder.models.sqla.filters.FilterEqual): ...
class UtcAwareFilterGreater(UtcAwareFilterMixin, flask_appbuilder.models.sqla.filters.FilterGreater): ...
class UtcAwareFilterSmaller(UtcAwareFilterMixin, flask_appbuilder.models.sqla.filters.FilterSmaller): ...
class UtcAwareFilterNotEqual(UtcAwareFilterMixin, flask_appbuilder.models.sqla.filters.FilterNotEqual): ...
class UtcAwareFilterConverter(flask_appbuilder.models.sqla.filters.SQLAFilterConverter): ...

class AirflowFilterConverter(flask_appbuilder.models.sqla.filters.SQLAFilterConverter):
    conversion_table: ClassVar[tuple] = ...
    def __init__(self, datamodel) -> None: ...

class CustomSQLAInterface(flask_appbuilder.models.sqla.interface.SQLAInterface):
    class filter_converter_class(flask_appbuilder.models.sqla.filters.SQLAFilterConverter):
        conversion_table: ClassVar[tuple] = ...
        def __init__(self, datamodel) -> None: ...
    def __init__(self, obj, session: Session | None = ...) -> None: ...
    def is_utcdatetime(self, col_name): ...
    def is_extendedjson(self, col_name): ...
    def get_col_default(self, col_name: str) -> Any: ...

class DagRunCustomSQLAInterface(CustomSQLAInterface):
    def delete(self, item: Model, raise_exception: bool = ...) -> bool: ...
    def delete_all(self, items: list[Model]) -> bool: ...

class UIAlert:
    def __init__(self, message: str | Markup, category: str = ..., roles: list[str] | None = ..., html: bool = ...) -> None: ...
    def should_show(self, appbuilder: AirflowAppBuilder) -> bool: ...
