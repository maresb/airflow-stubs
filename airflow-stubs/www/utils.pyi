import json
from _typeshed import Incomplete
from airflow.configuration import conf as conf
from airflow.exceptions import RemovedInAirflow3Warning as RemovedInAirflow3Warning
from airflow.models.dagrun import DagRun as DagRun
from airflow.models.dagwarning import DagWarning as DagWarning
from airflow.models.errors import ParseImportError as ParseImportError
from airflow.models.taskinstance import TaskInstance as TaskInstance
from airflow.utils import timezone as timezone
from airflow.utils.code_utils import get_python_source as get_python_source
from airflow.utils.helpers import alchemy_to_dict as alchemy_to_dict
from airflow.utils.json import WebEncoder as WebEncoder
from airflow.utils.sqlalchemy import tuple_in_condition as tuple_in_condition
from airflow.utils.state import State as State, TaskInstanceState as TaskInstanceState
from airflow.www.extensions.init_appbuilder import AirflowAppBuilder as AirflowAppBuilder
from airflow.www.extensions.init_auth_manager import get_auth_manager as get_auth_manager
from airflow.www.forms import DateTimeWithTimezoneField as DateTimeWithTimezoneField
from airflow.www.widgets import AirflowDateTimePickerWidget as AirflowDateTimePickerWidget
from flask_appbuilder.models.filters import BaseFilter
from flask_appbuilder.models.sqla import Model as Model, filters as fab_sqlafilters
from flask_appbuilder.models.sqla.interface import SQLAInterface
from markupsafe import Markup
from pendulum.datetime import DateTime as DateTime
from pygments.lexer import Lexer as Lexer
from sqlalchemy.orm.session import Session as Session
from sqlalchemy.sql import Select as Select
from sqlalchemy.sql.operators import ColumnOperators as ColumnOperators
from typing import Any, Callable, Sequence

TI = TaskInstance
logger: Incomplete

def datetime_to_string(value: DateTime | None) -> str | None: ...
def get_mapped_instances(task_instance, session): ...
def get_instance_with_map(task_instance, session): ...

priority: list[None | TaskInstanceState]

def get_mapped_summary(parent_instance, task_instances): ...
def get_dag_run_conf(dag_run_conf: Any, *, json_encoder: type[json.JSONEncoder] = ...) -> tuple[str | None, bool]: ...
def encode_dag_run(dag_run: DagRun | None, *, json_encoder: type[json.JSONEncoder] = ...) -> tuple[dict[str, Any] | None, None | str]: ...
def check_import_errors(fileloc, session) -> None: ...
def check_dag_warnings(dag_id, session) -> None: ...
def get_sensitive_variables_fields(): ...
def should_hide_value_for_key(key_name): ...
def get_params(**kwargs): ...
def generate_pages(current_page, num_of_pages, search: Incomplete | None = None, status: Incomplete | None = None, tags: Incomplete | None = None, window: int = 7, sorting_key: Incomplete | None = None, sorting_direction: Incomplete | None = None): ...
def epoch(dttm): ...
def make_cache_key(*args, **kwargs): ...
def task_instance_link(attr): ...
def state_token(state): ...
def state_f(attr): ...
def nobr_f(attr_name): ...
def datetime_f(attr_name): ...
def datetime_html(dttm: DateTime | None) -> str: ...
def json_f(attr_name): ...
def dag_link(attr): ...
def dag_run_link(attr): ...
def sorted_dag_runs(query: Select, *, ordering: Sequence[str], limit: int, session: Session) -> Sequence[DagRun]: ...
def format_map_index(attr: dict) -> str: ...
def pygment_html_render(s, lexer=...): ...
def render(obj: Any, lexer: Lexer, handler: Callable[[Any], str] | None = None): ...
def json_render(obj, lexer): ...
def wrapped_markdown(s, css_class: str = 'rich_doc'): ...
def get_attr_renderer(): ...

class UtcAwareFilterMixin:
    def apply(self, query, value): ...

class FilterIsNull(BaseFilter):
    name: Incomplete
    arg_name: str
    def apply(self, query, value): ...

class FilterIsNotNull(BaseFilter):
    name: Incomplete
    arg_name: str
    def apply(self, query, value): ...

class FilterGreaterOrEqual(BaseFilter):
    name: Incomplete
    arg_name: str
    def apply(self, query, value): ...

class FilterSmallerOrEqual(BaseFilter):
    name: Incomplete
    arg_name: str
    def apply(self, query, value): ...

class UtcAwareFilterSmallerOrEqual(UtcAwareFilterMixin, FilterSmallerOrEqual): ...
class UtcAwareFilterGreaterOrEqual(UtcAwareFilterMixin, FilterGreaterOrEqual): ...
class UtcAwareFilterEqual(UtcAwareFilterMixin, fab_sqlafilters.FilterEqual): ...
class UtcAwareFilterGreater(UtcAwareFilterMixin, fab_sqlafilters.FilterGreater): ...
class UtcAwareFilterSmaller(UtcAwareFilterMixin, fab_sqlafilters.FilterSmaller): ...
class UtcAwareFilterNotEqual(UtcAwareFilterMixin, fab_sqlafilters.FilterNotEqual): ...
class UtcAwareFilterConverter(fab_sqlafilters.SQLAFilterConverter): ...

class AirflowFilterConverter(fab_sqlafilters.SQLAFilterConverter):
    conversion_table: Incomplete
    def __init__(self, datamodel) -> None: ...

class CustomSQLAInterface(SQLAInterface):
    list_properties: Incomplete
    list_columns: Incomplete
    def __init__(self, obj, session: Session | None = None) -> None: ...
    def is_utcdatetime(self, col_name): ...
    def is_extendedjson(self, col_name): ...
    def get_col_default(self, col_name: str) -> Any: ...
    filter_converter_class = AirflowFilterConverter

class DagRunCustomSQLAInterface(CustomSQLAInterface):
    def delete(self, item: Model, raise_exception: bool = False) -> bool: ...
    def delete_all(self, items: list[Model]) -> bool: ...

class UIAlert:
    category: Incomplete
    roles: Incomplete
    html: Incomplete
    message: Incomplete
    def __init__(self, message: str | Markup, category: str = 'info', roles: list[str] | None = None, html: bool = False) -> None: ...
    def should_show(self, appbuilder: AirflowAppBuilder) -> bool: ...
