import typing
from _typeshed import Incomplete
from typing import Any, ClassVar

TYPE_CHECKING: bool

class DataInterval(tuple):
    _fields: ClassVar[tuple] = ...
    _field_defaults: ClassVar[dict] = ...
    _fields_defaults: ClassVar[dict] = ...
    _field_types: ClassVar[dict] = ...
    start: Incomplete
    end: Incomplete
    def __init__(self, _cls, start: DateTime, end: DateTime) -> None: ...
    def __getnewargs__(self): ...
    @classmethod
    def exact(cls, at: DateTime) -> DataInterval: ...

class TimeRestriction(tuple):
    _fields: ClassVar[tuple] = ...
    _field_defaults: ClassVar[dict] = ...
    _fields_defaults: ClassVar[dict] = ...
    _field_types: ClassVar[dict] = ...
    earliest: Incomplete
    latest: Incomplete
    catchup: Incomplete
    def __init__(self, _cls, earliest: DateTime | None, latest: DateTime | None, catchup: bool) -> None: ...
    def __getnewargs__(self): ...

class DagRunInfo(tuple):
    _fields: ClassVar[tuple] = ...
    _field_defaults: ClassVar[dict] = ...
    _fields_defaults: ClassVar[dict] = ...
    _field_types: ClassVar[dict] = ...
    run_after: Incomplete
    data_interval: Incomplete
    def __init__(self, _cls, run_after: DateTime, data_interval: DataInterval) -> None: ...
    def __getnewargs__(self): ...
    @classmethod
    def exact(cls, at: DateTime) -> DagRunInfo: ...
    @classmethod
    def interval(cls, start: DateTime, end: DateTime) -> DagRunInfo: ...
    @property
    def logical_date(self): ...

class Timetable(typing.Protocol):
    description: ClassVar[str] = ...
    periodic: ClassVar[bool] = ...
    _can_be_scheduled: ClassVar[bool] = ...
    run_ordering: ClassVar[tuple] = ...
    active_runs_limit: ClassVar[None] = ...
    __parameters__: ClassVar[tuple] = ...
    _is_protocol: ClassVar[bool] = ...
    __abstractmethods__: ClassVar[frozenset] = ...
    _abc_impl: ClassVar[_abc_data] = ...
    _is_runtime_protocol: ClassVar[bool] = ...
    @classmethod
    def deserialize(cls, data: dict[str, Any]) -> Timetable: ...
    def serialize(self) -> dict[str, Any]: ...
    def validate(self) -> None: ...
    def infer_manual_data_interval(self) -> DataInterval: ...
    def next_dagrun_info(self) -> DagRunInfo | None: ...
    def generate_run_id(self, **extra) -> str: ...
    def __subclasshook__(self, other): ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def can_be_scheduled(self): ...
    @property
    def summary(self): ...
