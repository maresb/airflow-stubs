from airflow.datasets import BaseDataset as BaseDataset, Dataset as Dataset
from airflow.serialization.dag_dependency import DagDependency as DagDependency
from airflow.typing_compat import Protocol as Protocol, runtime_checkable as runtime_checkable
from airflow.utils.types import DagRunType as DagRunType
from pendulum import DateTime as DateTime
from typing import Any, Iterator, NamedTuple, Sequence

class _NullDataset(BaseDataset):
    def __bool__(self) -> bool: ...
    def __or__(self, other: BaseDataset) -> BaseDataset: ...
    def __and__(self, other: BaseDataset) -> BaseDataset: ...
    def as_expression(self) -> Any: ...
    def evaluate(self, statuses: dict[str, bool]) -> bool: ...
    def iter_datasets(self) -> Iterator[tuple[str, Dataset]]: ...
    def iter_dag_dependencies(self, source, target) -> Iterator[DagDependency]: ...

class DataInterval(NamedTuple):
    start: DateTime
    end: DateTime
    @classmethod
    def exact(cls, at: DateTime) -> DataInterval: ...

class TimeRestriction(NamedTuple):
    earliest: DateTime | None
    latest: DateTime | None
    catchup: bool

class DagRunInfo(NamedTuple):
    run_after: DateTime
    data_interval: DataInterval
    @classmethod
    def exact(cls, at: DateTime) -> DagRunInfo: ...
    @classmethod
    def interval(cls, start: DateTime, end: DateTime) -> DagRunInfo: ...
    @property
    def logical_date(self) -> DateTime: ...

class Timetable(Protocol):
    description: str
    periodic: bool
    @property
    def can_be_scheduled(self): ...
    run_ordering: Sequence[str]
    active_runs_limit: int | None
    dataset_condition: BaseDataset
    @classmethod
    def deserialize(cls, data: dict[str, Any]) -> Timetable: ...
    def serialize(self) -> dict[str, Any]: ...
    def validate(self) -> None: ...
    @property
    def summary(self) -> str: ...
    def infer_manual_data_interval(self, *, run_after: DateTime) -> DataInterval: ...
    def next_dagrun_info(self, *, last_automated_data_interval: DataInterval | None, restriction: TimeRestriction) -> DagRunInfo | None: ...
    def generate_run_id(self, *, run_type: DagRunType, logical_date: DateTime, data_interval: DataInterval | None, **extra) -> str: ...
