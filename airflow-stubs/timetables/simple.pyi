import abc
from _typeshed import Incomplete
from airflow.datasets import BaseDataset as BaseDataset, DatasetAlias as DatasetAlias
from airflow.models.dataset import DatasetEvent as DatasetEvent
from airflow.timetables.base import DagRunInfo as DagRunInfo, DataInterval as DataInterval, TimeRestriction as TimeRestriction, Timetable as Timetable
from airflow.utils import timezone as timezone
from airflow.utils.types import DagRunType as DagRunType
from pendulum import DateTime as DateTime
from sqlalchemy import Session as Session
from typing import Any, Collection, Sequence

class _TrivialTimetable(Timetable, metaclass=abc.ABCMeta):
    periodic: bool
    run_ordering: Sequence[str]
    @classmethod
    def deserialize(cls, data: dict[str, Any]) -> Timetable: ...
    def __eq__(self, other: Any) -> bool: ...
    def serialize(self) -> dict[str, Any]: ...
    def infer_manual_data_interval(self, *, run_after: DateTime) -> DataInterval: ...

class NullTimetable(_TrivialTimetable):
    can_be_scheduled: bool
    description: str
    @property
    def summary(self) -> str: ...
    def next_dagrun_info(self, *, last_automated_data_interval: DataInterval | None, restriction: TimeRestriction) -> DagRunInfo | None: ...

class OnceTimetable(_TrivialTimetable):
    description: str
    @property
    def summary(self) -> str: ...
    def next_dagrun_info(self, *, last_automated_data_interval: DataInterval | None, restriction: TimeRestriction) -> DagRunInfo | None: ...

class ContinuousTimetable(_TrivialTimetable):
    description: str
    active_runs_limit: int
    @property
    def summary(self) -> str: ...
    def next_dagrun_info(self, *, last_automated_data_interval: DataInterval | None, restriction: TimeRestriction) -> DagRunInfo | None: ...

class DatasetTriggeredTimetable(_TrivialTimetable):
    description: str
    dataset_condition: Incomplete
    def __init__(self, datasets: BaseDataset) -> None: ...
    @classmethod
    def deserialize(cls, data: dict[str, Any]) -> Timetable: ...
    @property
    def summary(self) -> str: ...
    def serialize(self) -> dict[str, Any]: ...
    def generate_run_id(self, *, run_type: DagRunType, logical_date: DateTime, data_interval: DataInterval | None, session: Session | None = None, events: Collection[DatasetEvent] | None = None, **extra) -> str: ...
    def data_interval_for_events(self, logical_date: DateTime, events: Collection[DatasetEvent]) -> DataInterval: ...
    def next_dagrun_info(self, *, last_automated_data_interval: DataInterval | None, restriction: TimeRestriction) -> DagRunInfo | None: ...
