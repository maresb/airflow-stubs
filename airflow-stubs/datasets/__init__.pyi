import attr
import os
from _typeshed import Incomplete
from airflow.serialization.dag_dependency import DagDependency
from airflow.typing_compat import TypedDict
from typing import Any, Callable, ClassVar, Iterable, Iterator

__all__ = ['Dataset', 'DatasetAll', 'DatasetAny']

class BaseDataset:
    def __bool__(self) -> bool: ...
    def __or__(self, other: BaseDataset) -> BaseDataset: ...
    def __and__(self, other: BaseDataset) -> BaseDataset: ...
    def as_expression(self) -> Any: ...
    def evaluate(self, statuses: dict[str, bool]) -> bool: ...
    def iter_datasets(self) -> Iterator[tuple[str, Dataset]]: ...
    def iter_dataset_aliases(self) -> Iterator[DatasetAlias]: ...
    def iter_dag_dependencies(self, *, source: str, target: str) -> Iterator[DagDependency]: ...

@attr.define()
class DatasetAlias(BaseDataset):
    name: str
    def __eq__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...
    def iter_dag_dependencies(self, *, source: str, target: str) -> Iterator[DagDependency]: ...

class DatasetAliasEvent(TypedDict):
    source_alias_name: str
    dest_dataset_uri: str
    extra: dict[str, Any]

@attr.define()
class Dataset(os.PathLike, BaseDataset):
    uri: str = attr.field(converter=_sanitize_uri, validator=[attr.validators.min_len(1), attr.validators.max_len(3000)])
    extra: dict[str, Any] | None = ...
    __version__: ClassVar[int] = ...
    def __fspath__(self) -> str: ...
    def __eq__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...
    @property
    def normalized_uri(self) -> str | None: ...
    def as_expression(self) -> Any: ...
    def iter_datasets(self) -> Iterator[tuple[str, Dataset]]: ...
    def iter_dataset_aliases(self) -> Iterator[DatasetAlias]: ...
    def evaluate(self, statuses: dict[str, bool]) -> bool: ...
    def iter_dag_dependencies(self, *, source: str, target: str) -> Iterator[DagDependency]: ...

class _DatasetBooleanCondition(BaseDataset):
    agg_func: Callable[[Iterable], bool]
    objects: Incomplete
    def __init__(self, *objects: BaseDataset) -> None: ...
    def evaluate(self, statuses: dict[str, bool]) -> bool: ...
    def iter_datasets(self) -> Iterator[tuple[str, Dataset]]: ...
    def iter_dataset_aliases(self) -> Iterator[DatasetAlias]: ...
    def iter_dag_dependencies(self, *, source: str, target: str) -> Iterator[DagDependency]: ...

class DatasetAny(_DatasetBooleanCondition):
    agg_func = any
    def __or__(self, other: BaseDataset) -> BaseDataset: ...
    def as_expression(self) -> dict[str, Any]: ...

class _DatasetAliasCondition(DatasetAny):
    name: Incomplete
    objects: Incomplete
    def __init__(self, name: str) -> None: ...
    def as_expression(self) -> Any: ...
    def iter_dataset_aliases(self) -> Iterator[DatasetAlias]: ...
    def iter_dag_dependencies(self, *, source: str = '', target: str = '') -> Iterator[DagDependency]: ...

class DatasetAll(_DatasetBooleanCondition):
    agg_func = all
    def __and__(self, other: BaseDataset) -> BaseDataset: ...
    def as_expression(self) -> Any: ...
