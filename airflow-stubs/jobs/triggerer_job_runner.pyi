import asyncio
import threading
from _typeshed import Incomplete
from airflow.configuration import conf as conf
from airflow.jobs.base_job_runner import BaseJobRunner as BaseJobRunner
from airflow.jobs.job import Job as Job, perform_heartbeat as perform_heartbeat
from airflow.models import TaskInstance as TaskInstance
from airflow.models.trigger import Trigger as Trigger
from airflow.stats import Stats as Stats
from airflow.traces.tracer import Trace as Trace, span as span
from airflow.triggers.base import BaseTrigger as BaseTrigger, TriggerEvent as TriggerEvent
from airflow.typing_compat import TypedDict as TypedDict
from airflow.utils import timezone as timezone
from airflow.utils.log.file_task_handler import FileTaskHandler as FileTaskHandler
from airflow.utils.log.logging_mixin import LoggingMixin as LoggingMixin
from airflow.utils.log.trigger_handler import DropTriggerLogsFilter as DropTriggerLogsFilter, LocalQueueHandler as LocalQueueHandler, TriggerMetadataFilter as TriggerMetadataFilter, TriggererHandlerWrapper as TriggererHandlerWrapper, ctx_indiv_trigger as ctx_indiv_trigger, ctx_task_instance as ctx_task_instance, ctx_trigger_end as ctx_trigger_end, ctx_trigger_id as ctx_trigger_id
from airflow.utils.module_loading import import_string as import_string
from airflow.utils.session import NEW_SESSION as NEW_SESSION, provide_session as provide_session
from collections import deque
from sqlalchemy.orm import Session as Session

HANDLER_SUPPORTS_TRIGGERER: bool
SEND_TRIGGER_END_MARKER: bool
logger: Incomplete
DISABLE_WRAPPER: Incomplete
DISABLE_LISTENER: Incomplete

def configure_trigger_log_handler(): ...
def setup_queue_listener(): ...

class TriggererJobRunner(BaseJobRunner, LoggingMixin):
    job_type: str
    capacity: Incomplete
    health_check_threshold: Incomplete
    listener: Incomplete
    trigger_runner: Incomplete
    def __init__(self, job: Job, capacity: Incomplete | None = None) -> None: ...
    def heartbeat_callback(self, session: Session = ...) -> None: ...
    def register_signals(self) -> None: ...
    @classmethod
    def is_needed(cls, session) -> bool: ...
    def on_kill(self) -> None: ...
    def load_triggers(self) -> None: ...
    def handle_events(self) -> None: ...
    def handle_failed_triggers(self) -> None: ...
    def emit_metrics(self) -> None: ...

class TriggerDetails(TypedDict):
    task: asyncio.Task
    name: str
    events: int

class TriggerRunner(threading.Thread, LoggingMixin):
    triggers: dict[int, TriggerDetails]
    trigger_cache: dict[str, type[BaseTrigger]]
    to_create: deque[tuple[int, BaseTrigger]]
    to_cancel: deque[int]
    events: deque[tuple[int, TriggerEvent]]
    failed_triggers: deque[tuple[int, BaseException]]
    stop: bool
    job_id: Incomplete
    def __init__(self) -> None: ...
    def run(self) -> None: ...
    async def arun(self) -> None: ...
    async def create_triggers(self) -> None: ...
    async def cancel_triggers(self) -> None: ...
    async def cleanup_finished_triggers(self) -> None: ...
    async def block_watchdog(self) -> None: ...
    @staticmethod
    def set_individual_trigger_logging(trigger) -> None: ...
    async def run_trigger(self, trigger_id, trigger) -> None: ...
    @staticmethod
    def mark_trigger_end(trigger) -> None: ...
    def update_triggers(self, requested_trigger_ids: set[int]): ...
    def set_trigger_logging_metadata(self, ti: TaskInstance, trigger_id, trigger): ...
    def get_trigger_by_classpath(self, classpath: str) -> type[BaseTrigger]: ...
