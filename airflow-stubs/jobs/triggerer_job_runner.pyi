import airflow.jobs.base_job_runner
import airflow.utils.log.logging_mixin
import airflow.utils.timezone as timezone
import threading
from _typeshed import Incomplete
from airflow.configuration import conf as conf
from airflow.jobs.base_job_runner import BaseJobRunner as BaseJobRunner
from airflow.jobs.job import perform_heartbeat as perform_heartbeat
from airflow.models.trigger import Trigger as Trigger
from airflow.stats import Stats as Stats
from airflow.triggers.base import TriggerEvent as TriggerEvent
from airflow.utils.log.file_task_handler import FileTaskHandler as FileTaskHandler
from airflow.utils.log.logging_mixin import LoggingMixin as LoggingMixin
from airflow.utils.log.trigger_handler import DropTriggerLogsFilter as DropTriggerLogsFilter, LocalQueueHandler as LocalQueueHandler, TriggerMetadataFilter as TriggerMetadataFilter, TriggererHandlerWrapper as TriggererHandlerWrapper
from airflow.utils.module_loading import import_string as import_string
from airflow.utils.session import provide_session as provide_session
from typing import ClassVar

TYPE_CHECKING: bool
ctx_indiv_trigger: ContextVar
ctx_task_instance: ContextVar
ctx_trigger_end: ContextVar
ctx_trigger_id: ContextVar
NEW_SESSION: None
HANDLER_SUPPORTS_TRIGGERER: bool
SEND_TRIGGER_END_MARKER: bool
DISABLE_WRAPPER: bool
DISABLE_LISTENER: bool
def configure_trigger_log_handler(): ...
def setup_queue_listener(): ...

class TriggererJobRunner(airflow.jobs.base_job_runner.BaseJobRunner, airflow.utils.log.logging_mixin.LoggingMixin):
    job_type: ClassVar[str] = ...
    def __init__(self, job: Job, capacity: Incomplete | None = ...) -> None: ...
    def heartbeat_callback(self, *args, **kwargs) -> None: ...
    def register_signals(self) -> None: ...
    @classmethod
    def is_needed(cls, *args, **kwargs) -> bool: ...
    def on_kill(self): ...
    def load_triggers(self): ...
    def handle_events(self): ...
    def handle_failed_triggers(self): ...
    def emit_metrics(self): ...

class TriggerDetails(dict):
    __total__: ClassVar[bool] = ...
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...

class TriggerRunner(threading.Thread, airflow.utils.log.logging_mixin.LoggingMixin):
    stop: ClassVar[bool] = ...
    def __init__(self) -> None: ...
    def run(self): ...
    def arun(self): ...
    def create_triggers(self): ...
    def cancel_triggers(self): ...
    def cleanup_finished_triggers(self): ...
    def block_watchdog(self): ...
    @staticmethod
    def set_individual_trigger_logging(trigger): ...
    def run_trigger(self, trigger_id, trigger): ...
    @staticmethod
    def mark_trigger_end(trigger): ...
    def update_triggers(self, requested_trigger_ids: set[int]): ...
    def set_trigger_logging_metadata(self, ti: TaskInstance, trigger_id, trigger): ...
    def get_trigger_by_classpath(self, classpath: str) -> type[BaseTrigger]: ...
