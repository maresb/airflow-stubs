import jinja2
import re
import typing
from airflow.configuration import conf as conf
from airflow.exceptions import AirflowException as AirflowException, RemovedInAirflow3Warning as RemovedInAirflow3Warning
from airflow.utils.module_loading import import_string as import_string
from airflow.utils.types import NOTSET as NOTSET
from typing import Any, Callable, Generator, Iterable, Mapping, MutableMapping

TYPE_CHECKING: bool
KEY_REGEX: re.Pattern
GROUP_KEY_REGEX: re.Pattern
CAMELCASE_TO_SNAKE_CASE_REGEX: re.Pattern
T: typing.TypeVar
S: typing.TypeVar
def validate_key(k: str, max_length: int = ...): ...
def validate_group_key(k: str, max_length: int = ...): ...
def alchemy_to_dict(obj: Any) -> dict | None: ...
def ask_yesno(question: str, default: bool | None = ...) -> bool: ...
def prompt_with_timeout(question: str, timeout: int, default: bool | None = ...) -> bool: ...
def is_container(obj: Any) -> bool: ...
def as_tuple(obj: Any) -> tuple: ...
def chunks(items: list[T], chunk_size: int) -> Generator[list[T], None, None]: ...
def reduce_in_chunks(fn: Callable[[S, list[T]], S], iterable: list[T], initializer: S, chunk_size: int = ...): ...
def as_flattened_list(iterable: Iterable[Iterable[T]]) -> list[T]: ...
def parse_template_string(template_string: str) -> tuple[str | None, jinja2.Template | None]: ...
def render_log_filename(ti: TaskInstance, try_number, filename_template) -> str: ...
def convert_camel_to_snake(camel_str: str) -> str: ...
def merge_dicts(dict1: dict, dict2: dict) -> dict: ...
def partition(pred: Callable[[T], bool], iterable: Iterable[T]) -> tuple[Iterable[T], Iterable[T]]: ...
def chain(*args, **kwargs): ...
def cross_downstream(*args, **kwargs): ...
def build_airflow_url_with_query(query: dict[str, Any]) -> str: ...
def render_template(template: Any, context: MutableMapping[str, Any]) -> Any: ...
def render_template_to_string(template: jinja2.Template, context: Context) -> str: ...
def render_template_as_native(template: jinja2.Template, context: Context) -> Any: ...
def exactly_one(*args) -> bool: ...
def at_most_one(*args) -> bool: ...
def prune_dict(val: Any, mode: str = ...): ...
def prevent_duplicates(kwargs1: dict[str, Any], kwargs2: Mapping[str, Any]) -> None: ...
