import jinja2
from _typeshed import Incomplete
from airflow.configuration import conf as conf
from airflow.exceptions import AirflowException as AirflowException, RemovedInAirflow3Warning as RemovedInAirflow3Warning
from airflow.models.taskinstance import TaskInstance as TaskInstance
from airflow.utils.context import Context as Context
from airflow.utils.module_loading import import_string as import_string
from airflow.utils.types import NOTSET as NOTSET
from typing import Any, Callable, Generator, Iterable, Mapping, MutableMapping, TypeVar

KEY_REGEX: Incomplete
GROUP_KEY_REGEX: Incomplete
CAMELCASE_TO_SNAKE_CASE_REGEX: Incomplete
T = TypeVar('T')
S = TypeVar('S')

def validate_key(k: str, max_length: int = 250): ...
def validate_instance_args(instance: object, expected_arg_types: dict[str, Any]) -> None: ...
def validate_group_key(k: str, max_length: int = 200): ...
def alchemy_to_dict(obj: Any) -> dict | None: ...
def ask_yesno(question: str, default: bool | None = None) -> bool: ...
def prompt_with_timeout(question: str, timeout: int, default: bool | None = None) -> bool: ...
def is_container(obj: Any) -> bool: ...
def as_tuple(obj: Any) -> tuple: ...
def chunks(items: list[T], chunk_size: int) -> Generator[list[T], None, None]: ...
def reduce_in_chunks(fn: Callable[[S, list[T]], S], iterable: list[T], initializer: S, chunk_size: int = 0): ...
def as_flattened_list(iterable: Iterable[Iterable[T]]) -> list[T]: ...
def parse_template_string(template_string: str) -> tuple[str | None, jinja2.Template | None]: ...
def render_log_filename(ti: TaskInstance, try_number, filename_template) -> str: ...
def convert_camel_to_snake(camel_str: str) -> str: ...
def merge_dicts(dict1: dict, dict2: dict) -> dict: ...
def partition(pred: Callable[[T], bool], iterable: Iterable[T]) -> tuple[Iterable[T], Iterable[T]]: ...
def chain(*args, **kwargs): ...
def cross_downstream(*args, **kwargs): ...
def build_airflow_url_with_query(query: dict[str, Any]) -> str: ...
def render_template(template: Any, context: MutableMapping[str, Any], *, native: bool) -> Any: ...
def render_template_to_string(template: jinja2.Template, context: Context) -> str: ...
def render_template_as_native(template: jinja2.Template, context: Context) -> Any: ...
def exactly_one(*args) -> bool: ...
def at_most_one(*args) -> bool: ...
def prune_dict(val: Any, mode: str = 'strict'): ...
def prevent_duplicates(kwargs1: dict[str, Any], kwargs2: Mapping[str, Any], *, fail_reason: str) -> None: ...
