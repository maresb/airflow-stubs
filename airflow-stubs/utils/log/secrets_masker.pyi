import logging
from _typeshed import Incomplete
from airflow import settings as settings
from airflow.compat.functools import cache as cache
from airflow.typing_compat import TypeGuard as TypeGuard
from functools import cached_property as cached_property
from typing import Any, Iterable, Iterator, Pattern, TextIO, TypeVar

Redactable = TypeVar('Redactable', str, 'V1EnvVar', dict[Any, Any], tuple[Any, ...], list[Any])
Redacted = Redactable | str
log: Incomplete
DEFAULT_SENSITIVE_FIELDS: Incomplete
SECRETS_TO_SKIP_MASKING_FOR_TESTS: Incomplete

def get_sensitive_variables_fields(): ...
def should_hide_value_for_key(name): ...
def mask_secret(secret: str | dict | Iterable, name: str | None = None) -> None: ...
def redact(value: Redactable, name: str | None = None, max_depth: int | None = None) -> Redacted: ...

class SecretsMasker(logging.Filter):
    replacer: Pattern | None
    patterns: set[str]
    ALREADY_FILTERED_FLAG: str
    MAX_RECURSION_DEPTH: int
    def __init__(self) -> None: ...
    def filter(self, record) -> bool: ...
    def redact(self, item: Redactable, name: str | None = None, max_depth: int | None = None) -> Redacted: ...
    def add_mask(self, secret: str | dict | Iterable, name: str | None = None): ...

class RedactedIO(TextIO):
    target: Incomplete
    def __init__(self) -> None: ...
    def __enter__(self) -> TextIO: ...
    def __exit__(self, t: type[BaseException] | None, v: BaseException | None, b: types.TracebackType | None) -> None: ...
    def __iter__(self) -> Iterator[str]: ...
    def __next__(self) -> str: ...
    def close(self) -> None: ...
    def fileno(self) -> int: ...
    def flush(self) -> None: ...
    def isatty(self) -> bool: ...
    def read(self, n: int = -1) -> str: ...
    def readable(self) -> bool: ...
    def readline(self, n: int = -1) -> str: ...
    def readlines(self, n: int = -1) -> list[str]: ...
    def seek(self, offset: int, whence: int = 0) -> int: ...
    def seekable(self) -> bool: ...
    def tell(self) -> int: ...
    def truncate(self, s: int | None = None) -> int: ...
    def writable(self) -> bool: ...
    def write(self, s: str) -> int: ...
    def writelines(self, lines) -> None: ...
