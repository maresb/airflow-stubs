import airflow.models.taskmixin
import functools
import types
from airflow.exceptions import AirflowDagCycleException as AirflowDagCycleException, AirflowException as AirflowException, DuplicateTaskIdFound as DuplicateTaskIdFound, TaskAlreadyInTaskGroup as TaskAlreadyInTaskGroup
from airflow.models.taskmixin import DAGNode as DAGNode
from airflow.serialization.enums import DagAttributeTypes as DagAttributeTypes
from airflow.utils.helpers import validate_group_key as validate_group_key
from typing import Any, ClassVar, Generator, Iterator

TYPE_CHECKING: bool

class TaskGroup(airflow.models.taskmixin.DAGNode):
    __abstractmethods__: ClassVar[frozenset] = ...
    _abc_impl: ClassVar[_abc_data] = ...
    def __init__(self, group_id: str | None, prefix_group_id: bool = ..., parent_group: TaskGroup | None = ..., dag: DAG | None = ..., default_args: dict[str, Any] | None = ..., tooltip: str = ..., ui_color: str = ..., ui_fgcolor: str = ..., add_suffix_on_collision: bool = ...) -> None: ...
    @classmethod
    def create_root(cls, dag: DAG) -> TaskGroup: ...
    def __iter__(self): ...
    def add(self, task: DAGNode) -> DAGNode: ...
    def update_relative(self, other: DependencyMixin, upstream: bool = ..., edge_modifier: EdgeModifier | None = ...) -> None: ...
    def __enter__(self) -> TaskGroup: ...
    def __exit__(self, _type: type[BaseException] | None, _value: BaseException | None, _tb: types.TracebackType | None): ...
    def has_task(self, task: BaseOperator) -> bool: ...
    def get_roots(self) -> Generator[BaseOperator, None, None]: ...
    def get_leaves(self) -> Generator[BaseOperator, None, None]: ...
    def child_id(self, label): ...
    def get_task_group_dict(self) -> dict[str, TaskGroup]: ...
    def get_child_by_label(self, label: str) -> DAGNode: ...
    def serialize_for_task_group(self) -> tuple[DagAttributeTypes, Any]: ...
    def hierarchical_alphabetical_sort(self): ...
    def topological_sort(self, _include_subdag_tasks: bool = ...): ...
    def iter_mapped_task_groups(self) -> Iterator[MappedTaskGroup]: ...
    def iter_tasks(self) -> Iterator[AbstractOperator]: ...
    @property
    def node_id(self): ...
    @property
    def is_root(self): ...
    @property
    def parent_group(self): ...
    @property
    def group_id(self): ...
    @property
    def label(self): ...
    @property
    def roots(self): ...
    @property
    def leaves(self): ...
    @property
    def upstream_join_id(self): ...
    @property
    def downstream_join_id(self): ...

class MappedTaskGroup(TaskGroup):
    get_parse_time_mapped_ti_count: ClassVar[functools._lru_cache_wrapper] = ...
    __abstractmethods__: ClassVar[frozenset] = ...
    _abc_impl: ClassVar[_abc_data] = ...
    def __init__(self, **kwargs: Any) -> None: ...
    def iter_mapped_dependencies(self) -> Iterator[Operator]: ...
    def get_mapped_ti_count(self, run_id: str) -> int: ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None): ...

class TaskGroupContext:
    active: ClassVar[bool] = ...
    _context_managed_task_group: ClassVar[None] = ...
    _previous_context_managed_task_groups: ClassVar[list] = ...
    @classmethod
    def push_context_managed_task_group(cls, task_group: TaskGroup): ...
    @classmethod
    def pop_context_managed_task_group(cls) -> TaskGroup | None: ...
    @classmethod
    def get_current_task_group(cls, dag: DAG | None) -> TaskGroup | None: ...
def task_group_to_dict(task_item_or_group): ...
