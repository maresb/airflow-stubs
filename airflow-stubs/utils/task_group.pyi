from _typeshed import Incomplete
from airflow.exceptions import AirflowDagCycleException as AirflowDagCycleException, AirflowException as AirflowException, DuplicateTaskIdFound as DuplicateTaskIdFound, TaskAlreadyInTaskGroup as TaskAlreadyInTaskGroup
from airflow.models.abstractoperator import AbstractOperator as AbstractOperator
from airflow.models.baseoperator import BaseOperator as BaseOperator
from airflow.models.dag import DAG as DAG
from airflow.models.expandinput import ExpandInput as ExpandInput
from airflow.models.operator import Operator as Operator
from airflow.models.taskmixin import DAGNode as DAGNode, DependencyMixin as DependencyMixin
from airflow.serialization.enums import DagAttributeTypes as DagAttributeTypes
from airflow.utils.edgemodifier import EdgeModifier as EdgeModifier
from airflow.utils.helpers import validate_group_key as validate_group_key, validate_instance_args as validate_instance_args
from airflow.utils.trigger_rule import TriggerRule as TriggerRule
from sqlalchemy.orm import Session as Session
from typing import Any, Generator, Iterator

TASKGROUP_ARGS_EXPECTED_TYPES: Incomplete

class TaskGroup(DAGNode):
    used_group_ids: set[str | None]
    prefix_group_id: Incomplete
    default_args: Incomplete
    dag: Incomplete
    children: dict[str, DAGNode]
    tooltip: Incomplete
    ui_color: Incomplete
    ui_fgcolor: Incomplete
    upstream_group_ids: set[str | None]
    downstream_group_ids: set[str | None]
    upstream_task_ids: Incomplete
    downstream_task_ids: Incomplete
    def __init__(self, group_id: str | None, prefix_group_id: bool = True, parent_group: TaskGroup | None = None, dag: DAG | None = None, default_args: dict[str, Any] | None = None, tooltip: str = '', ui_color: str = 'CornflowerBlue', ui_fgcolor: str = '#000', add_suffix_on_collision: bool = False) -> None: ...
    @classmethod
    def create_root(cls, dag: DAG) -> TaskGroup: ...
    @property
    def node_id(self): ...
    @property
    def is_root(self) -> bool: ...
    @property
    def parent_group(self) -> TaskGroup | None: ...
    def __iter__(self): ...
    def add(self, task: DAGNode) -> DAGNode: ...
    @property
    def group_id(self) -> str | None: ...
    @property
    def label(self) -> str | None: ...
    def update_relative(self, other: DependencyMixin, upstream: bool = True, edge_modifier: EdgeModifier | None = None) -> None: ...
    def __enter__(self) -> TaskGroup: ...
    def __exit__(self, _type: type[BaseException] | None, _value: BaseException | None, _tb: types.TracebackType | None) -> None: ...
    def has_task(self, task: BaseOperator) -> bool: ...
    @property
    def roots(self) -> list[BaseOperator]: ...
    @property
    def leaves(self) -> list[BaseOperator]: ...
    def get_roots(self) -> Generator[BaseOperator, None, None]: ...
    def get_leaves(self) -> Generator[BaseOperator, None, None]: ...
    def child_id(self, label): ...
    @property
    def upstream_join_id(self) -> str: ...
    @property
    def downstream_join_id(self) -> str: ...
    def get_task_group_dict(self) -> dict[str, TaskGroup]: ...
    def get_child_by_label(self, label: str) -> DAGNode: ...
    def serialize_for_task_group(self) -> tuple[DagAttributeTypes, Any]: ...
    def hierarchical_alphabetical_sort(self): ...
    def topological_sort(self, _include_subdag_tasks: bool = False): ...
    def iter_mapped_task_groups(self) -> Iterator[MappedTaskGroup]: ...
    def iter_tasks(self) -> Iterator[AbstractOperator]: ...

class MappedTaskGroup(TaskGroup):
    def __init__(self, *, expand_input: ExpandInput, **kwargs: Any) -> None: ...
    def __iter__(self): ...
    def iter_mapped_dependencies(self) -> Iterator[Operator]: ...
    def get_parse_time_mapped_ti_count(self) -> int: ...
    def get_mapped_ti_count(self, run_id: str, *, session: Session) -> int: ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None) -> None: ...

class TaskGroupContext:
    active: bool
    @classmethod
    def push_context_managed_task_group(cls, task_group: TaskGroup): ...
    @classmethod
    def pop_context_managed_task_group(cls) -> TaskGroup | None: ...
    @classmethod
    def get_current_task_group(cls, dag: DAG | None) -> TaskGroup | None: ...

def task_group_to_dict(task_item_or_group): ...
