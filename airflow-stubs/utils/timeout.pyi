import airflow.utils.log.logging_mixin
import contextlib
import types
import typing
from airflow.exceptions import AirflowTaskTimeout as AirflowTaskTimeout
from airflow.utils.log.logging_mixin import LoggingMixin as LoggingMixin
from typing import ClassVar

IS_WINDOWS: bool

class TimeoutWindows(contextlib.AbstractContextManager, typing.Generic, airflow.utils.log.logging_mixin.LoggingMixin):
    __orig_bases__: ClassVar[tuple] = ...
    __parameters__: ClassVar[tuple] = ...
    __abstractmethods__: ClassVar[frozenset] = ...
    _abc_impl: ClassVar[_abc_data] = ...
    def __init__(self, seconds: int = ..., error_message: str = ...) -> None: ...
    def handle_timeout(self, *args): ...
    def __enter__(self): ...
    def __exit__(self, type_: type[BaseException] | None, value: BaseException | None, traceback: types.TracebackType | None): ...

class TimeoutPosix(contextlib.AbstractContextManager, typing.Generic, airflow.utils.log.logging_mixin.LoggingMixin):
    __orig_bases__: ClassVar[tuple] = ...
    __parameters__: ClassVar[tuple] = ...
    __abstractmethods__: ClassVar[frozenset] = ...
    _abc_impl: ClassVar[_abc_data] = ...
    def __init__(self, seconds: int = ..., error_message: str = ...) -> None: ...
    def handle_timeout(self, signum, frame): ...
    def __enter__(self): ...
    def __exit__(self, type_: type[BaseException] | None, value: BaseException | None, traceback: types.TracebackType | None): ...

class timeout(contextlib.AbstractContextManager, typing.Generic, airflow.utils.log.logging_mixin.LoggingMixin):
    __orig_bases__: ClassVar[tuple] = ...
    __parameters__: ClassVar[tuple] = ...
    __abstractmethods__: ClassVar[frozenset] = ...
    _abc_impl: ClassVar[_abc_data] = ...
    def __init__(self, seconds: int = ..., error_message: str = ...) -> None: ...
    def handle_timeout(self, signum, frame): ...
    def __enter__(self): ...
    def __exit__(self, type_: type[BaseException] | None, value: BaseException | None, traceback: types.TracebackType | None): ...
