from airflow.exceptions import AirflowException as AirflowException
from airflow.models.abstractoperator import AbstractOperator as AbstractOperator
from airflow.models.taskmixin import DependencyMixin as DependencyMixin
from airflow.models.xcom_arg import PlainXComArg as PlainXComArg

class BaseSetupTeardownContext:
    active: bool
    context_map: dict[AbstractOperator | tuple[AbstractOperator], list[AbstractOperator]]
    @classmethod
    def push_context_managed_setup_task(cls, task: AbstractOperator | list[AbstractOperator]): ...
    @classmethod
    def push_context_managed_teardown_task(cls, task: AbstractOperator | list[AbstractOperator]): ...
    @classmethod
    def pop_context_managed_setup_task(cls) -> AbstractOperator | list[AbstractOperator]: ...
    @classmethod
    def pop_context_managed_teardown_task(cls) -> AbstractOperator | list[AbstractOperator]: ...
    @classmethod
    def pop_teardown_downstream_of_setup(cls) -> AbstractOperator | list[AbstractOperator]: ...
    @classmethod
    def pop_setup_upstream_of_teardown(cls) -> AbstractOperator | list[AbstractOperator]: ...
    @classmethod
    def set_dependency(cls, receiving_task: AbstractOperator | list[AbstractOperator], new_task: AbstractOperator | list[AbstractOperator], upstream: bool = True): ...
    @classmethod
    def update_context_map(cls, task: DependencyMixin): ...
    @classmethod
    def push_setup_teardown_task(cls, operator: AbstractOperator | list[AbstractOperator]): ...
    @classmethod
    def set_teardown_task_as_leaves(cls, leaves) -> None: ...
    @classmethod
    def set_setup_task_as_roots(cls, roots) -> None: ...
    @classmethod
    def set_work_task_roots_and_leaves(cls) -> None: ...
    @classmethod
    def set_setup_teardown_relationships(cls) -> None: ...
    @classmethod
    def error(cls, message: str): ...

class SetupTeardownContext(BaseSetupTeardownContext):
    @staticmethod
    def add_task(task: AbstractOperator | PlainXComArg): ...
