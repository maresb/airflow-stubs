import airflow.models.baseoperator
import airflow.models.dag
import dataclasses
import functools
import relativedelta
from _typeshed import Incomplete
from airflow.configuration import conf as conf
from airflow.datasets import Dataset as Dataset
from airflow.exceptions import AirflowException as AirflowException, RemovedInAirflow3Warning as RemovedInAirflow3Warning, SerializationError as SerializationError
from airflow.jobs.job import Job as Job
from airflow.models.baseoperator import BaseOperator as BaseOperator
from airflow.models.connection import Connection as Connection
from airflow.models.dag import DAG as DAG, DagModel as DagModel, create_timetable as create_timetable
from airflow.models.dagrun import DagRun as DagRun
from airflow.models.expandinput import EXPAND_INPUT_EMPTY as EXPAND_INPUT_EMPTY, create_expand_input as create_expand_input, get_map_type_key as get_map_type_key
from airflow.models.mappedoperator import MappedOperator as MappedOperator
from airflow.models.param import Param as Param, ParamsDict as ParamsDict
from airflow.models.taskinstance import SimpleTaskInstance as SimpleTaskInstance, TaskInstance as TaskInstance
from airflow.models.tasklog import LogTemplate as LogTemplate
from airflow.models.xcom_arg import XComArg as XComArg, deserialize_xcom_arg as deserialize_xcom_arg, serialize_xcom_arg as serialize_xcom_arg
from airflow.providers_manager import ProvidersManager as ProvidersManager
from airflow.serialization.enums import DAT as DAT, Encoding as Encoding
from airflow.serialization.helpers import serialize_template_field as serialize_template_field
from airflow.serialization.json_schema import load_dag_schema as load_dag_schema
from airflow.serialization.pydantic.dag import DagModelPydantic as DagModelPydantic
from airflow.serialization.pydantic.dag_run import DagRunPydantic as DagRunPydantic
from airflow.serialization.pydantic.dataset import DatasetPydantic as DatasetPydantic
from airflow.serialization.pydantic.job import JobPydantic as JobPydantic
from airflow.serialization.pydantic.taskinstance import TaskInstancePydantic as TaskInstancePydantic
from airflow.serialization.pydantic.tasklog import LogTemplatePydantic as LogTemplatePydantic
from airflow.utils.code_utils import get_python_source as get_python_source
from airflow.utils.decorators import warnings as warnings
from airflow.utils.docs import get_docs_url as get_docs_url
from airflow.utils.module_loading import import_string as import_string, qualname as qualname
from airflow.utils.operator_resources import Resources as Resources
from airflow.utils.task_group import MappedTaskGroup as MappedTaskGroup, TaskGroup as TaskGroup
from airflow.utils.timezone import from_timestamp as from_timestamp, parse_timezone as parse_timezone
from airflow.utils.types import ArgNotSet as ArgNotSet, NOTSET as NOTSET
from pendulum.tz.timezone import FixedTimezone, Timezone
from typing import Any, ClassVar, Iterable, _ExpandInputOriginalValue, _ExpandInputSerializedValue

TYPE_CHECKING: bool
DAGS_FOLDER: str
get_operator_extra_links: functools._lru_cache_wrapper
def encode_relativedelta(var: relativedelta.relativedelta) -> dict[str, Any]: ...
def decode_relativedelta(var: dict[str, Any]) -> relativedelta.relativedelta: ...
def encode_timezone(var: Timezone | FixedTimezone) -> str | int: ...
def decode_timezone(var: str | int) -> Timezone | FixedTimezone: ...

class _TimetableNotRegistered(ValueError):
    def __init__(self, type_string: str) -> None: ...

class _XComRef(tuple):
    _fields: ClassVar[tuple] = ...
    _field_defaults: ClassVar[dict] = ...
    _fields_defaults: ClassVar[dict] = ...
    _field_types: ClassVar[dict] = ...
    data: Incomplete
    def __init__(self, _cls, data: dict) -> None: ...
    def __getnewargs__(self): ...
    def deref(self, dag: DAG) -> XComArg: ...

class _ExpandInputRef(tuple):
    _fields: ClassVar[tuple] = ...
    _field_defaults: ClassVar[dict] = ...
    _fields_defaults: ClassVar[dict] = ...
    _field_types: ClassVar[dict] = ...
    key: Incomplete
    value: Incomplete
    def __init__(self, _cls, key: str, value: _ExpandInputSerializedValue) -> None: ...
    def __getnewargs__(self): ...
    @classmethod
    def validate_expand_input_value(cls, value: _ExpandInputOriginalValue) -> None: ...
    def deref(self, dag: DAG) -> ExpandInput: ...

class BaseSerialization:
    _primitive_types: ClassVar[tuple] = ...
    _datetime_types: ClassVar[tuple] = ...
    _excluded_types: ClassVar[tuple] = ...
    _json_schema: ClassVar[None] = ...
    _load_operator_extra_links: ClassVar[bool] = ...
    _CONSTRUCTOR_PARAMS: ClassVar[dict] = ...
    SERIALIZER_VERSION: ClassVar[int] = ...
    @classmethod
    def to_json(cls, var: DAG | BaseOperator | dict | list | set | tuple) -> str: ...
    @classmethod
    def to_dict(cls, var: DAG | BaseOperator | dict | list | set | tuple) -> dict: ...
    @classmethod
    def from_json(cls, serialized_obj: str) -> BaseSerialization | dict | list | set | tuple: ...
    @classmethod
    def from_dict(cls, serialized_obj: dict[Encoding, Any]) -> BaseSerialization | dict | list | set | tuple: ...
    @classmethod
    def validate_schema(cls, serialized_obj: str | dict) -> None: ...
    @classmethod
    def serialize_to_json(cls, object_to_serialize: BaseOperator | MappedOperator | DAG, decorated_fields: set) -> dict[str, Any]: ...
    @classmethod
    def serialize(cls, var: Any) -> Any: ...
    @classmethod
    def default_serialization(cls, strict, var) -> str: ...
    @classmethod
    def deserialize(cls, encoded_var: Any, use_pydantic_models: bool = ...) -> Any: ...

class DependencyDetector:
    @staticmethod
    def detect_task_dependencies(task: Operator) -> list[DagDependency]: ...
    @staticmethod
    def detect_dag_dependencies(dag: DAG | None) -> Iterable[DagDependency]: ...

class SerializedBaseOperator(airflow.models.baseoperator.BaseOperator, BaseSerialization):
    _decorated_fields: ClassVar[set] = ...
    _CONSTRUCTOR_PARAMS: ClassVar[dict] = ...
    __abstractmethods__: ClassVar[frozenset] = ...
    _abc_impl: ClassVar[_abc_data] = ...
    task_type: Incomplete
    operator_name: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def serialize_mapped_operator(cls, op: MappedOperator) -> dict[str, Any]: ...
    @classmethod
    def serialize_operator(cls, op: BaseOperator | MappedOperator) -> dict[str, Any]: ...
    @classmethod
    def populate_operator(cls, op: Operator, encoded_op: dict[str, Any]) -> None: ...
    @staticmethod
    def set_task_dag_references(task: Operator, dag: DAG) -> None: ...
    @classmethod
    def deserialize_operator(cls, encoded_op: dict[str, Any]) -> Operator: ...
    @classmethod
    def detect_dependencies(cls, op: Operator) -> set[DagDependency]: ...
    @classmethod
    def serialize(cls, var: Any) -> Any: ...
    @classmethod
    def deserialize(cls, encoded_var: Any, use_pydantic_models: bool = ...) -> Any: ...

class SerializedDAG(airflow.models.dag.DAG, BaseSerialization):
    _decorated_fields: ClassVar[set] = ...
    _CONSTRUCTOR_PARAMS: ClassVar[dict] = ...
    _json_schema: ClassVar[Proxy] = ...
    @classmethod
    def serialize_dag(cls, dag: DAG) -> dict: ...
    @classmethod
    def deserialize_dag(cls, encoded_dag: dict[str, Any]) -> SerializedDAG: ...
    @classmethod
    def to_dict(cls, var: Any) -> dict: ...
    @classmethod
    def from_dict(cls, serialized_obj: dict) -> SerializedDAG: ...

class TaskGroupSerialization(BaseSerialization):
    @classmethod
    def serialize_task_group(cls, task_group: TaskGroup) -> dict[str, Any] | None: ...
    @classmethod
    def deserialize_task_group(cls, encoded_group: dict[str, Any], parent_group: TaskGroup | None, task_dict: dict[str, Operator], dag: SerializedDAG) -> TaskGroup: ...

class DagDependency:
    dependency_id: ClassVar[None] = ...
    __dataclass_params__: ClassVar[dataclasses._DataclassParams] = ...
    __dataclass_fields__: ClassVar[dict] = ...
    def __init__(self, source: str, target: str, dependency_type: str, dependency_id: str | None = ...) -> None: ...
    def __eq__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __le__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def __setattr__(self, name, value): ...
    def __delattr__(self, name): ...
    def __hash__(self) -> int: ...
    @property
    def node_id(self): ...
