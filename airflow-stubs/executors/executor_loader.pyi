import enum
from airflow.exceptions import AirflowConfigException as AirflowConfigException
from airflow.utils.module_loading import import_string as import_string
from typing import ClassVar

TYPE_CHECKING: bool
CELERY_EXECUTOR: str
CELERY_KUBERNETES_EXECUTOR: str
DEBUG_EXECUTOR: str
KUBERNETES_EXECUTOR: str
LOCAL_EXECUTOR: str
LOCAL_KUBERNETES_EXECUTOR: str
SEQUENTIAL_EXECUTOR: str

class ConnectorSource(enum.Enum):
    _member_names_: ClassVar[list] = ...
    _member_map_: ClassVar[dict] = ...
    _member_type_: ClassVar[type[object]] = ...
    _value2member_map_: ClassVar[dict] = ...
    CORE: ClassVar[ConnectorSource] = ...
    PLUGIN: ClassVar[ConnectorSource] = ...
    CUSTOM_PATH: ClassVar[ConnectorSource] = ...
    @classmethod
    def __init__(cls, value) -> None: ...

class ExecutorLoader:
    _default_executor: ClassVar[None] = ...
    executors: ClassVar[dict] = ...
    @classmethod
    def get_default_executor_name(cls) -> str: ...
    @classmethod
    def get_default_executor(cls) -> BaseExecutor: ...
    @classmethod
    def load_executor(cls, executor_name: str) -> BaseExecutor: ...
    @classmethod
    def import_executor_cls(cls, executor_name: str, validate: bool = ...) -> tuple[type[BaseExecutor], ConnectorSource]: ...
    @classmethod
    def import_default_executor_cls(cls, validate: bool = ...) -> tuple[type[BaseExecutor], ConnectorSource]: ...
    @classmethod
    def validate_database_executor_compatibility(cls, *args, **kwargs): ...
UNPICKLEABLE_EXECUTORS: tuple
