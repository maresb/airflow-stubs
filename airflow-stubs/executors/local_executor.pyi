import airflow.executors.base_executor
import airflow.settings as settings
import airflow.utils.log.logging_mixin
import multiprocessing.context
from airflow.exceptions import AirflowException as AirflowException
from airflow.executors.base_executor import BaseExecutor as BaseExecutor
from airflow.utils.log.logging_mixin import LoggingMixin as LoggingMixin
from airflow.utils.state import TaskInstanceState as TaskInstanceState
from typing import Any, ClassVar

TYPE_CHECKING: bool
PARALLELISM: int

class LocalWorkerBase(multiprocessing.context.Process, airflow.utils.log.logging_mixin.LoggingMixin):
    def __init__(self, result_queue: Queue[TaskInstanceStateType]) -> None: ...
    def run(self): ...
    def execute_work(self, key: TaskInstanceKey, command: CommandType) -> None: ...
    def do_work(self): ...

class LocalWorker(LocalWorkerBase):
    def __init__(self, result_queue: Queue[TaskInstanceStateType], key: TaskInstanceKey, command: CommandType) -> None: ...
    def do_work(self) -> None: ...

class QueuedLocalWorker(LocalWorkerBase):
    def __init__(self, task_queue: Queue[ExecutorWorkType], result_queue: Queue[TaskInstanceStateType]) -> None: ...
    def do_work(self) -> None: ...

class LocalExecutor(airflow.executors.base_executor.BaseExecutor):
    class UnlimitedParallelism:
        def __init__(self, executor: LocalExecutor) -> None: ...
        def start(self) -> None: ...
        def execute_async(self, key: TaskInstanceKey, command: CommandType, queue: str | None = ..., executor_config: Any | None = ...) -> None: ...
        def sync(self) -> None: ...
        def end(self) -> None: ...

    class LimitedParallelism:
        def __init__(self, executor: LocalExecutor) -> None: ...
        def start(self) -> None: ...
        def execute_async(self, key: TaskInstanceKey, command: CommandType, queue: str | None = ..., executor_config: Any | None = ...) -> None: ...
        def sync(self): ...
        def end(self): ...
    is_local: ClassVar[bool] = ...
    supports_pickling: ClassVar[bool] = ...
    serve_logs: ClassVar[bool] = ...
    def __init__(self, parallelism: int = ...) -> None: ...
    def start(self) -> None: ...
    def execute_async(self, key: TaskInstanceKey, command: CommandType, queue: str | None = ..., executor_config: Any | None = ...) -> None: ...
    def sync(self) -> None: ...
    def end(self) -> None: ...
    def terminate(self): ...
