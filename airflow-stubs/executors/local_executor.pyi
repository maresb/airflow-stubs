import abc
from _typeshed import Incomplete
from abc import abstractmethod
from airflow import settings as settings
from airflow.exceptions import AirflowException as AirflowException
from airflow.executors.base_executor import BaseExecutor as BaseExecutor, CommandType as CommandType, PARALLELISM as PARALLELISM
from airflow.models.taskinstance import TaskInstanceStateType as TaskInstanceStateType
from airflow.models.taskinstancekey import TaskInstanceKey as TaskInstanceKey
from airflow.traces.tracer import Trace as Trace, span as span
from airflow.utils.log.logging_mixin import LoggingMixin as LoggingMixin
from airflow.utils.state import TaskInstanceState as TaskInstanceState
from multiprocessing import Process
from multiprocessing.managers import SyncManager
from queue import Queue
from typing import Any

ExecutorWorkType = tuple[TaskInstanceKey | None, CommandType | None]

class LocalWorkerBase(Process, LoggingMixin, metaclass=abc.ABCMeta):
    daemon: bool
    result_queue: Queue[TaskInstanceStateType]
    def __init__(self, result_queue: Queue[TaskInstanceStateType]) -> None: ...
    def run(self): ...
    def execute_work(self, key: TaskInstanceKey, command: CommandType) -> None: ...
    @abstractmethod
    def do_work(self): ...

class LocalWorker(LocalWorkerBase):
    key: TaskInstanceKey
    command: CommandType
    def __init__(self, result_queue: Queue[TaskInstanceStateType], key: TaskInstanceKey, command: CommandType) -> None: ...
    def do_work(self) -> None: ...

class QueuedLocalWorker(LocalWorkerBase):
    task_queue: Incomplete
    def __init__(self, task_queue: Queue[ExecutorWorkType], result_queue: Queue[TaskInstanceStateType]) -> None: ...
    def do_work(self) -> None: ...

class LocalExecutor(BaseExecutor):
    is_local: bool
    supports_pickling: bool
    serve_logs: bool
    manager: SyncManager | None
    result_queue: Queue[TaskInstanceStateType] | None
    workers: list[QueuedLocalWorker]
    workers_used: int
    workers_active: int
    impl: None | LocalExecutor.UnlimitedParallelism | LocalExecutor.LimitedParallelism
    def __init__(self, parallelism: int = ...) -> None: ...
    class UnlimitedParallelism:
        executor: LocalExecutor
        def __init__(self, executor: LocalExecutor) -> None: ...
        def start(self) -> None: ...
        def execute_async(self, key: TaskInstanceKey, command: CommandType, queue: str | None = None, executor_config: Any | None = None) -> None: ...
        def sync(self) -> None: ...
        def end(self) -> None: ...
    class LimitedParallelism:
        executor: LocalExecutor
        queue: Queue[ExecutorWorkType] | None
        def __init__(self, executor: LocalExecutor) -> None: ...
        def start(self) -> None: ...
        def execute_async(self, key: TaskInstanceKey, command: CommandType, queue: str | None = None, executor_config: Any | None = None) -> None: ...
        def sync(self) -> None: ...
        def end(self) -> None: ...
    def start(self) -> None: ...
    def execute_async(self, key: TaskInstanceKey, command: CommandType, queue: str | None = None, executor_config: Any | None = None) -> None: ...
    def sync(self) -> None: ...
    def end(self) -> None: ...
    def terminate(self) -> None: ...
