import attr
import inspect
from _typeshed import Incomplete
from airflow.datasets import Dataset as Dataset
from airflow.models.abstractoperator import DEFAULT_RETRIES as DEFAULT_RETRIES, DEFAULT_RETRY_DELAY as DEFAULT_RETRY_DELAY
from airflow.models.baseoperator import BaseOperator as BaseOperator, coerce_resources as coerce_resources, coerce_timedelta as coerce_timedelta, get_merged_defaults as get_merged_defaults, parse_retries as parse_retries
from airflow.models.dag import DAG as DAG, DagContext as DagContext
from airflow.models.expandinput import DictOfListsExpandInput as DictOfListsExpandInput, EXPAND_INPUT_EMPTY as EXPAND_INPUT_EMPTY, ExpandInput as ExpandInput, ListOfDictsExpandInput as ListOfDictsExpandInput, OperatorExpandArgument as OperatorExpandArgument, OperatorExpandKwargsArgument as OperatorExpandKwargsArgument, is_mappable as is_mappable
from airflow.models.mappedoperator import MappedOperator as MappedOperator, ValidationSource as ValidationSource, ensure_xcomarg_return_value as ensure_xcomarg_return_value
from airflow.models.pool import Pool as Pool
from airflow.models.xcom_arg import XComArg as XComArg
from airflow.typing_compat import ParamSpec as ParamSpec, Protocol as Protocol
from airflow.utils import timezone as timezone
from airflow.utils.context import Context as Context, KNOWN_CONTEXT_KEYS as KNOWN_CONTEXT_KEYS
from airflow.utils.decorators import remove_task_decorator as remove_task_decorator
from airflow.utils.helpers import prevent_duplicates as prevent_duplicates
from airflow.utils.task_group import TaskGroup as TaskGroup, TaskGroupContext as TaskGroupContext
from airflow.utils.trigger_rule import TriggerRule as TriggerRule
from airflow.utils.types import NOTSET as NOTSET
from functools import cached_property as cached_property
from sqlalchemy.orm import Session as Session
from typing import Any, Callable, Collection, Generic, Mapping, Sequence, TypeVar, overload

class ExpandableFactory(Protocol):
    function: Callable
    @cached_property
    def function_signature(self) -> inspect.Signature: ...

def get_unique_task_id(task_id: str, dag: DAG | None = None, task_group: TaskGroup | None = None) -> str: ...

class DecoratedOperator(BaseOperator):
    template_fields: Sequence[str]
    template_fields_renderers: Incomplete
    shallow_copy_attrs: Sequence[str]
    python_callable: Incomplete
    op_args: Incomplete
    op_kwargs: Incomplete
    def __init__(self, *, python_callable: Callable, task_id: str, op_args: Collection[Any] | None = None, op_kwargs: Mapping[str, Any] | None = None, kwargs_to_upstream: dict[str, Any] | None = None, **kwargs) -> None: ...
    def execute(self, context: Context): ...
    def get_python_source(self): ...
FParams = ParamSpec('FParams')
FReturn = TypeVar('FReturn')
OperatorSubclass = TypeVar('OperatorSubclass', bound='BaseOperator')

@attr.define(slots=False)
class _TaskDecorator(ExpandableFactory, Generic[FParams, FReturn, OperatorSubclass]):
    function: Callable[FParams, FReturn] = ...
    operator_class: type[OperatorSubclass]
    multiple_outputs: bool = ...
    kwargs: dict[str, Any] = ...
    decorator_name: str = ...
    is_setup: bool = ...
    is_teardown: bool = ...
    on_failure_fail_dagrun: bool = ...
    def __attrs_post_init__(self) -> None: ...
    def __call__(self, *args: FParams.args, **kwargs: FParams.kwargs) -> XComArg: ...
    @property
    def __wrapped__(self) -> Callable[FParams, FReturn]: ...
    def expand(self, **map_kwargs: OperatorExpandArgument) -> XComArg: ...
    def expand_kwargs(self, kwargs: OperatorExpandKwargsArgument, *, strict: bool = True) -> XComArg: ...
    def partial(self, **kwargs: Any) -> _TaskDecorator[FParams, FReturn, OperatorSubclass]: ...
    def override(self, **kwargs: Any) -> _TaskDecorator[FParams, FReturn, OperatorSubclass]: ...

@attr.define(kw_only=True, repr=False)
class DecoratedMappedOperator(MappedOperator):
    multiple_outputs: bool
    python_callable: Callable
    op_kwargs_expand_input: ExpandInput
    def __hash__(self): ...
    def __attrs_post_init__(self) -> None: ...

class Task(Protocol, Generic[FParams, FReturn]):
    __call__: Callable[FParams, XComArg]
    function: Callable[FParams, FReturn]
    @property
    def __wrapped__(self) -> Callable[FParams, FReturn]: ...
    def partial(self, **kwargs: Any) -> Task[FParams, FReturn]: ...
    def expand(self, **kwargs: OperatorExpandArgument) -> XComArg: ...
    def expand_kwargs(self, kwargs: OperatorExpandKwargsArgument, *, strict: bool = True) -> XComArg: ...
    def override(self, **kwargs: Any) -> Task[FParams, FReturn]: ...

class TaskDecorator(Protocol):
    @overload
    def __call__(self, python_callable: Callable[FParams, FReturn]) -> Task[FParams, FReturn]: ...
    @overload
    def __call__(self, *, multiple_outputs: bool | None = None, **kwargs: Any) -> Callable[[Callable[FParams, FReturn]], Task[FParams, FReturn]]: ...
    def override(self, **kwargs: Any) -> Task[FParams, FReturn]: ...

def task_decorator_factory(python_callable: Callable | None = None, *, multiple_outputs: bool | None = None, decorated_operator_class: type[BaseOperator], **kwargs) -> TaskDecorator: ...
