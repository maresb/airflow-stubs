import abc
import datetime
import jinja2
from airflow.configuration import conf as conf
from airflow.exceptions import AirflowException as AirflowException
from airflow.models.baseoperator import BaseOperator as BaseOperator
from airflow.models.baseoperatorlink import BaseOperatorLink as BaseOperatorLink
from airflow.models.dag import DAG as DAG
from airflow.models.expandinput import NotFullyPopulated as NotFullyPopulated
from airflow.models.mappedoperator import MappedOperator as MappedOperator
from airflow.models.operator import Operator as Operator
from airflow.models.taskinstance import TaskInstance as TaskInstance
from airflow.models.taskmixin import DAGNode as DAGNode, DependencyMixin as DependencyMixin
from airflow.task.priority_strategy import PriorityWeightStrategy as PriorityWeightStrategy
from airflow.template.templater import Templater as Templater
from airflow.triggers.base import StartTriggerArgs as StartTriggerArgs
from airflow.utils.context import Context as Context
from airflow.utils.db import exists_query as exists_query
from airflow.utils.log.secrets_masker import redact as redact
from airflow.utils.setup_teardown import SetupTeardownContext as SetupTeardownContext
from airflow.utils.sqlalchemy import with_row_locks as with_row_locks
from airflow.utils.state import State as State, TaskInstanceState as TaskInstanceState
from airflow.utils.task_group import MappedTaskGroup as MappedTaskGroup, TaskGroup as TaskGroup
from airflow.utils.trigger_rule import TriggerRule as TriggerRule
from airflow.utils.types import ArgNotSet as ArgNotSet, NOTSET as NOTSET
from airflow.utils.weight_rule import WeightRule as WeightRule, db_safe_priority as db_safe_priority
from functools import cached_property as cached_property
from sqlalchemy.orm import Session as Session
from typing import Any, Callable, ClassVar, Collection, Iterable, Iterator, Sequence

TaskStateChangeCallback = Callable[[Context], None]
DEFAULT_OWNER: str
DEFAULT_POOL_SLOTS: int
DEFAULT_PRIORITY_WEIGHT: int
DEFAULT_EXECUTOR: str | None
DEFAULT_QUEUE: str
DEFAULT_IGNORE_FIRST_DEPENDS_ON_PAST: bool
DEFAULT_WAIT_FOR_PAST_DEPENDS_BEFORE_SKIPPING: bool
DEFAULT_RETRIES: int
DEFAULT_RETRY_DELAY: datetime.timedelta
MAX_RETRY_DELAY: int
DEFAULT_WEIGHT_RULE: WeightRule
DEFAULT_TRIGGER_RULE: TriggerRule
DEFAULT_TASK_EXECUTION_TIMEOUT: datetime.timedelta | None

class NotMapped(Exception): ...

class AbstractOperator(Templater, DAGNode, metaclass=abc.ABCMeta):
    operator_class: type[BaseOperator] | dict[str, Any]
    weight_rule: PriorityWeightStrategy
    priority_weight: int
    operator_extra_links: Collection[BaseOperatorLink]
    owner: str
    task_id: str
    outlets: list
    inlets: list
    trigger_rule: TriggerRule
    HIDE_ATTRS_FROM_UI: ClassVar[frozenset[str]]
    def get_dag(self) -> DAG | None: ...
    @property
    def task_type(self) -> str: ...
    @property
    def operator_name(self) -> str: ...
    @property
    def inherits_from_empty_operator(self) -> bool: ...
    @property
    def dag_id(self) -> str: ...
    @property
    def node_id(self) -> str: ...
    @property
    @abc.abstractmethod
    def task_display_name(self) -> str: ...
    @property
    def label(self) -> str | None: ...
    @property
    def is_setup(self) -> bool: ...
    @is_setup.setter
    def is_setup(self, value: bool) -> None: ...
    @property
    def is_teardown(self) -> bool: ...
    @is_teardown.setter
    def is_teardown(self, value: bool) -> None: ...
    @property
    def on_failure_fail_dagrun(self): ...
    @on_failure_fail_dagrun.setter
    def on_failure_fail_dagrun(self, value) -> None: ...
    def as_setup(self): ...
    def as_teardown(self, *, setups: BaseOperator | Iterable[BaseOperator] | ArgNotSet = ..., on_failure_fail_dagrun=...): ...
    def get_direct_relative_ids(self, upstream: bool = False) -> set[str]: ...
    def get_flat_relative_ids(self, *, upstream: bool = False) -> set[str]: ...
    def get_flat_relatives(self, upstream: bool = False) -> Collection[Operator]: ...
    def get_upstreams_follow_setups(self) -> Iterable[Operator]: ...
    def get_upstreams_only_setups_and_teardowns(self) -> Iterable[Operator]: ...
    def get_upstreams_only_setups(self) -> Iterable[Operator]: ...
    def iter_mapped_dependants(self) -> Iterator[MappedOperator | MappedTaskGroup]: ...
    def iter_mapped_task_groups(self) -> Iterator[MappedTaskGroup]: ...
    def get_closest_mapped_task_group(self) -> MappedTaskGroup | None: ...
    def get_needs_expansion(self) -> bool: ...
    def unmap(self, resolve: None | dict[str, Any] | tuple[Context, Session]) -> BaseOperator: ...
    def expand_start_from_trigger(self, *, context: Context, session: Session) -> bool: ...
    def expand_start_trigger_args(self, *, context: Context, session: Session) -> StartTriggerArgs | None: ...
    @property
    def priority_weight_total(self) -> int: ...
    @cached_property
    def operator_extra_link_dict(self) -> dict[str, Any]: ...
    @cached_property
    def global_operator_extra_link_dict(self) -> dict[str, Any]: ...
    @cached_property
    def extra_links(self) -> list[str]: ...
    def get_extra_links(self, ti: TaskInstance, link_name: str) -> str | None: ...
    def get_parse_time_mapped_ti_count(self) -> int: ...
    def get_mapped_ti_count(self, run_id: str, *, session: Session) -> int: ...
    def expand_mapped_task(self, run_id: str, *, session: Session) -> tuple[Sequence[TaskInstance], int]: ...
    def render_template_fields(self, context: Context, jinja_env: jinja2.Environment | None = None) -> None: ...
    def get_template_env(self, dag: DAG | None = None) -> jinja2.Environment: ...
    def __enter__(self): ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None) -> None: ...
