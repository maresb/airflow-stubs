import attr
import datetime
import jinja2
import pendulum
from _typeshed import Incomplete
from airflow.exceptions import AirflowException as AirflowException, UnmappableOperator as UnmappableOperator
from airflow.models.abstractoperator import AbstractOperator as AbstractOperator, DEFAULT_EXECUTOR as DEFAULT_EXECUTOR, DEFAULT_IGNORE_FIRST_DEPENDS_ON_PAST as DEFAULT_IGNORE_FIRST_DEPENDS_ON_PAST, DEFAULT_OWNER as DEFAULT_OWNER, DEFAULT_POOL_SLOTS as DEFAULT_POOL_SLOTS, DEFAULT_PRIORITY_WEIGHT as DEFAULT_PRIORITY_WEIGHT, DEFAULT_QUEUE as DEFAULT_QUEUE, DEFAULT_RETRIES as DEFAULT_RETRIES, DEFAULT_RETRY_DELAY as DEFAULT_RETRY_DELAY, DEFAULT_TRIGGER_RULE as DEFAULT_TRIGGER_RULE, DEFAULT_WAIT_FOR_PAST_DEPENDS_BEFORE_SKIPPING as DEFAULT_WAIT_FOR_PAST_DEPENDS_BEFORE_SKIPPING, DEFAULT_WEIGHT_RULE as DEFAULT_WEIGHT_RULE, NotMapped as NotMapped, TaskStateChangeCallback as TaskStateChangeCallback
from airflow.models.baseoperator import BaseOperator as BaseOperator
from airflow.models.baseoperatorlink import BaseOperatorLink as BaseOperatorLink
from airflow.models.dag import DAG as DAG
from airflow.models.expandinput import DictOfListsExpandInput as DictOfListsExpandInput, ExpandInput as ExpandInput, ListOfDictsExpandInput as ListOfDictsExpandInput, OperatorExpandArgument as OperatorExpandArgument, OperatorExpandKwargsArgument as OperatorExpandKwargsArgument, is_mappable as is_mappable
from airflow.models.operator import Operator as Operator
from airflow.models.param import ParamsDict as ParamsDict
from airflow.models.pool import Pool as Pool
from airflow.models.xcom_arg import XComArg as XComArg
from airflow.serialization.enums import DagAttributeTypes as DagAttributeTypes
from airflow.task.priority_strategy import PriorityWeightStrategy as PriorityWeightStrategy, validate_and_load_priority_weight_strategy as validate_and_load_priority_weight_strategy
from airflow.ti_deps.deps.base_ti_dep import BaseTIDep as BaseTIDep
from airflow.ti_deps.deps.mapped_task_expanded import MappedTaskIsExpanded as MappedTaskIsExpanded
from airflow.triggers.base import StartTriggerArgs as StartTriggerArgs
from airflow.typing_compat import Literal as Literal
from airflow.utils.context import Context as Context, context_update_for_unmapped as context_update_for_unmapped
from airflow.utils.helpers import is_container as is_container, prevent_duplicates as prevent_duplicates
from airflow.utils.operator_resources import Resources as Resources
from airflow.utils.task_group import TaskGroup as TaskGroup
from airflow.utils.task_instance_session import get_current_task_instance_session as get_current_task_instance_session
from airflow.utils.trigger_rule import TriggerRule as TriggerRule
from airflow.utils.types import NOTSET as NOTSET
from airflow.utils.xcom import XCOM_RETURN_KEY as XCOM_RETURN_KEY
from sqlalchemy.orm.session import Session as Session
from typing import Any, ClassVar, Collection, Iterable, Iterator, Mapping, Sequence

TaskStateChangeCallbackAttrType = None | TaskStateChangeCallback | list[TaskStateChangeCallback]
ValidationSource: Incomplete

def validate_mapping_kwargs(op: type[BaseOperator], func: ValidationSource, value: dict[str, Any]) -> None: ...
def ensure_xcomarg_return_value(arg: Any) -> None: ...

@attr.define(kw_only=True, repr=False)
class OperatorPartial:
    operator_class: type[BaseOperator]
    kwargs: dict[str, Any]
    params: ParamsDict | dict
    def __attrs_post_init__(self) -> None: ...
    def __del__(self) -> None: ...
    def expand(self, **mapped_kwargs: OperatorExpandArgument) -> MappedOperator: ...
    def expand_kwargs(self, kwargs: OperatorExpandKwargsArgument, *, strict: bool = True) -> MappedOperator: ...

@attr.define(kw_only=True, getstate_setstate=False)
class MappedOperator(AbstractOperator):
    operator_class: type[BaseOperator] | dict[str, Any]
    expand_input: ExpandInput
    partial_kwargs: dict[str, Any]
    task_id: str
    params: ParamsDict | dict
    deps: frozenset[BaseTIDep]
    operator_extra_links: Collection[BaseOperatorLink]
    template_ext: Sequence[str]
    template_fields: Collection[str]
    template_fields_renderers: dict[str, str]
    ui_color: str
    ui_fgcolor: str
    start_trigger_args: StartTriggerArgs | None
    start_from_trigger: bool
    dag: DAG | None
    task_group: TaskGroup | None
    start_date: pendulum.DateTime | None
    end_date: pendulum.DateTime | None
    upstream_task_ids: set[str] = ...
    downstream_task_ids: set[str] = ...
    subdag: None = ...
    supports_lineage: bool = ...
    HIDE_ATTRS_FROM_UI: ClassVar[frozenset[str]] = ...
    def __hash__(self): ...
    def __attrs_post_init__(self) -> None: ...
    @classmethod
    def get_serialized_fields(cls): ...
    @staticmethod
    def deps_for(operator_class: type[BaseOperator]) -> frozenset[BaseTIDep]: ...
    @property
    def task_type(self) -> str: ...
    @property
    def operator_name(self) -> str: ...
    @property
    def inherits_from_empty_operator(self) -> bool: ...
    @property
    def roots(self) -> Sequence[AbstractOperator]: ...
    @property
    def leaves(self) -> Sequence[AbstractOperator]: ...
    @property
    def task_display_name(self) -> str: ...
    @property
    def owner(self) -> str: ...
    @property
    def email(self) -> None | str | Iterable[str]: ...
    @property
    def map_index_template(self) -> None | str: ...
    @map_index_template.setter
    def map_index_template(self, value: str | None) -> None: ...
    @property
    def trigger_rule(self) -> TriggerRule: ...
    @trigger_rule.setter
    def trigger_rule(self, value) -> None: ...
    @property
    def is_setup(self) -> bool: ...
    @is_setup.setter
    def is_setup(self, value: bool) -> None: ...
    @property
    def is_teardown(self) -> bool: ...
    @is_teardown.setter
    def is_teardown(self, value: bool) -> None: ...
    @property
    def depends_on_past(self) -> bool: ...
    @depends_on_past.setter
    def depends_on_past(self, value: bool) -> None: ...
    @property
    def ignore_first_depends_on_past(self) -> bool: ...
    @ignore_first_depends_on_past.setter
    def ignore_first_depends_on_past(self, value: bool) -> None: ...
    @property
    def wait_for_past_depends_before_skipping(self) -> bool: ...
    @wait_for_past_depends_before_skipping.setter
    def wait_for_past_depends_before_skipping(self, value: bool) -> None: ...
    @property
    def wait_for_downstream(self) -> bool: ...
    @wait_for_downstream.setter
    def wait_for_downstream(self, value: bool) -> None: ...
    @property
    def retries(self) -> int: ...
    @retries.setter
    def retries(self, value: int) -> None: ...
    @property
    def queue(self) -> str: ...
    @queue.setter
    def queue(self, value: str) -> None: ...
    @property
    def pool(self) -> str: ...
    @pool.setter
    def pool(self, value: str) -> None: ...
    @property
    def pool_slots(self) -> int: ...
    @pool_slots.setter
    def pool_slots(self, value: int) -> None: ...
    @property
    def execution_timeout(self) -> datetime.timedelta | None: ...
    @execution_timeout.setter
    def execution_timeout(self, value: datetime.timedelta | None) -> None: ...
    @property
    def max_retry_delay(self) -> datetime.timedelta | None: ...
    @max_retry_delay.setter
    def max_retry_delay(self, value: datetime.timedelta | None) -> None: ...
    @property
    def retry_delay(self) -> datetime.timedelta: ...
    @retry_delay.setter
    def retry_delay(self, value: datetime.timedelta) -> None: ...
    @property
    def retry_exponential_backoff(self) -> bool: ...
    @retry_exponential_backoff.setter
    def retry_exponential_backoff(self, value: bool) -> None: ...
    @property
    def priority_weight(self) -> int: ...
    @priority_weight.setter
    def priority_weight(self, value: int) -> None: ...
    @property
    def weight_rule(self) -> PriorityWeightStrategy: ...
    @weight_rule.setter
    def weight_rule(self, value: str | PriorityWeightStrategy) -> None: ...
    @property
    def sla(self) -> datetime.timedelta | None: ...
    @sla.setter
    def sla(self, value: datetime.timedelta | None) -> None: ...
    @property
    def max_active_tis_per_dag(self) -> int | None: ...
    @max_active_tis_per_dag.setter
    def max_active_tis_per_dag(self, value: int | None) -> None: ...
    @property
    def max_active_tis_per_dagrun(self) -> int | None: ...
    @max_active_tis_per_dagrun.setter
    def max_active_tis_per_dagrun(self, value: int | None) -> None: ...
    @property
    def resources(self) -> Resources | None: ...
    @property
    def on_execute_callback(self) -> TaskStateChangeCallbackAttrType: ...
    @on_execute_callback.setter
    def on_execute_callback(self, value: TaskStateChangeCallbackAttrType) -> None: ...
    @property
    def on_failure_callback(self) -> TaskStateChangeCallbackAttrType: ...
    @on_failure_callback.setter
    def on_failure_callback(self, value: TaskStateChangeCallbackAttrType) -> None: ...
    @property
    def on_retry_callback(self) -> TaskStateChangeCallbackAttrType: ...
    @on_retry_callback.setter
    def on_retry_callback(self, value: TaskStateChangeCallbackAttrType) -> None: ...
    @property
    def on_success_callback(self) -> TaskStateChangeCallbackAttrType: ...
    @on_success_callback.setter
    def on_success_callback(self, value: TaskStateChangeCallbackAttrType) -> None: ...
    @property
    def on_skipped_callback(self) -> TaskStateChangeCallbackAttrType: ...
    @on_skipped_callback.setter
    def on_skipped_callback(self, value: TaskStateChangeCallbackAttrType) -> None: ...
    @property
    def run_as_user(self) -> str | None: ...
    @property
    def executor(self) -> str | None: ...
    @property
    def executor_config(self) -> dict: ...
    @property
    def inlets(self) -> list[Any]: ...
    @inlets.setter
    def inlets(self, value: list[Any]) -> None: ...
    @property
    def outlets(self) -> list[Any]: ...
    @outlets.setter
    def outlets(self, value: list[Any]) -> None: ...
    @property
    def doc(self) -> str | None: ...
    @property
    def doc_md(self) -> str | None: ...
    @property
    def doc_json(self) -> str | None: ...
    @property
    def doc_yaml(self) -> str | None: ...
    @property
    def doc_rst(self) -> str | None: ...
    @property
    def allow_nested_operators(self) -> bool: ...
    def get_dag(self) -> DAG | None: ...
    @property
    def output(self) -> XComArg: ...
    def serialize_for_task_group(self) -> tuple[DagAttributeTypes, Any]: ...
    def expand_start_from_trigger(self, *, context: Context, session: Session) -> bool: ...
    def expand_start_trigger_args(self, *, context: Context, session: Session) -> StartTriggerArgs | None: ...
    def unmap(self, resolve: None | Mapping[str, Any] | tuple[Context, Session]) -> BaseOperator: ...
    def prepare_for_execution(self) -> MappedOperator: ...
    def iter_mapped_dependencies(self) -> Iterator[Operator]: ...
    def get_parse_time_mapped_ti_count(self) -> int: ...
    def get_mapped_ti_count(self, run_id: str, *, session: Session) -> int: ...
    def render_template_fields(self, context: Context, jinja_env: jinja2.Environment | None = None) -> None: ...
