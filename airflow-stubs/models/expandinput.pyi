import airflow.utils.mixins
from _typeshed import Incomplete
from airflow.utils.mixins import ResolveMixin as ResolveMixin
from airflow.utils.session import provide_session as provide_session
from typing import Any, ClassVar, ExpandInput, Iterable, Mapping, OperatorExpandArgument, OperatorExpandKwargsArgument

TYPE_CHECKING: bool
NEW_SESSION: None

class MappedArgument(airflow.utils.mixins.ResolveMixin):
    __attrs_attrs__: ClassVar[MappedArgumentAttributes] = ...
    __attrs_own_setattr__: ClassVar[bool] = ...
    def get_task_map_length(self, run_id: str) -> int | None: ...
    def iter_references(self) -> Iterable[tuple[Operator, str]]: ...
    def resolve(self, *args, **kwargs) -> Any: ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __init__(self) -> None: ...
def is_mappable(v: Any) -> TypeGuard[OperatorExpandArgument]: ...

class NotFullyPopulated(RuntimeError):
    def __init__(self, missing: set[str]) -> None: ...

class DictOfListsExpandInput(tuple):
    _fields: ClassVar[tuple] = ...
    _field_defaults: ClassVar[dict] = ...
    _fields_defaults: ClassVar[dict] = ...
    _field_types: ClassVar[dict] = ...
    value: Incomplete
    def __init__(self, _cls, value: dict[str, OperatorExpandArgument]) -> None: ...
    def __getnewargs__(self): ...
    def get_parse_time_mapped_ti_count(self) -> int: ...
    def get_total_map_length(self, run_id: str) -> int: ...
    def iter_references(self) -> Iterable[tuple[Operator, str]]: ...
    def resolve(self, context: Context, session: Session) -> tuple[Mapping[str, Any], set[int]]: ...

class ListOfDictsExpandInput(tuple):
    _fields: ClassVar[tuple] = ...
    _field_defaults: ClassVar[dict] = ...
    _fields_defaults: ClassVar[dict] = ...
    _field_types: ClassVar[dict] = ...
    value: Incomplete
    def __init__(self, _cls, value: OperatorExpandKwargsArgument) -> None: ...
    def __getnewargs__(self): ...
    def get_parse_time_mapped_ti_count(self) -> int: ...
    def get_total_map_length(self, run_id: str) -> int: ...
    def iter_references(self) -> Iterable[tuple[Operator, str]]: ...
    def resolve(self, context: Context, session: Session) -> tuple[Mapping[str, Any], set[int]]: ...
EXPAND_INPUT_EMPTY: DictOfListsExpandInput
def get_map_type_key(expand_input: ExpandInput) -> str: ...
def create_expand_input(kind: str, value: Any) -> ExpandInput: ...
