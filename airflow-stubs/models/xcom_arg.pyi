import airflow.models.taskmixin
import airflow.utils.mixins
import collections.abc
import types
import typing
from _typeshed import Incomplete
from airflow.exceptions import AirflowException as AirflowException, XComNotFound as XComNotFound
from airflow.models.abstractoperator import AbstractOperator as AbstractOperator
from airflow.models.mappedoperator import MappedOperator as MappedOperator
from airflow.models.taskmixin import DependencyMixin as DependencyMixin
from airflow.utils.db import exists_query as exists_query
from airflow.utils.mixins import ResolveMixin as ResolveMixin
from airflow.utils.session import provide_session as provide_session
from airflow.utils.setup_teardown import SetupTeardownContext as SetupTeardownContext
from airflow.utils.state import State as State
from airflow.utils.trigger_rule import TriggerRule as TriggerRule
from airflow.utils.types import ArgNotSet as ArgNotSet, NOTSET as NOTSET
from typing import Any, Callable, ClassVar, Iterator, MapCallables, Sequence

TYPE_CHECKING: bool
NEW_SESSION: None
XCOM_RETURN_KEY: str

class XComArg(airflow.utils.mixins.ResolveMixin, airflow.models.taskmixin.DependencyMixin):
    @classmethod
    def __init__(cls, *args, **kwargs) -> XComArg: ...
    @staticmethod
    def iter_xcom_references(arg: Any) -> Iterator[tuple[Operator, str]]: ...
    @staticmethod
    def apply_upstream_relationship(op: Operator, arg: Any): ...
    def set_upstream(self, task_or_task_list: DependencyMixin | Sequence[DependencyMixin], edge_modifier: EdgeModifier | None = ...): ...
    def set_downstream(self, task_or_task_list: DependencyMixin | Sequence[DependencyMixin], edge_modifier: EdgeModifier | None = ...): ...
    def map(self, f: Callable[[Any], Any]) -> MapXComArg: ...
    def zip(self, *others: XComArg) -> ZipXComArg: ...
    def get_task_map_length(self, run_id: str) -> int | None: ...
    def resolve(self, *args, **kwargs) -> Any: ...
    def __enter__(self): ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None): ...
    @property
    def roots(self): ...
    @property
    def leaves(self): ...

class PlainXComArg(XComArg):
    is_setup: Incomplete
    is_teardown: Incomplete
    on_failure_fail_dagrun: Incomplete
    def __init__(self, operator: Operator, key: str = ...) -> None: ...
    def __eq__(self, other: Any) -> bool: ...
    def __getitem__(self, item: str) -> XComArg: ...
    def __iter__(self): ...
    def as_setup(self) -> DependencyMixin: ...
    def as_teardown(self): ...
    def iter_references(self) -> Iterator[tuple[Operator, str]]: ...
    def map(self, f: Callable[[Any], Any]) -> MapXComArg: ...
    def zip(self, *others: XComArg) -> ZipXComArg: ...
    def get_task_map_length(self, run_id: str) -> int | None: ...
    def resolve(self, *args, **kwargs) -> Any: ...

class _MapResult(collections.abc.Sequence, typing.Generic):
    __orig_bases__: ClassVar[tuple] = ...
    __parameters__: ClassVar[tuple] = ...
    __abstractmethods__: ClassVar[frozenset] = ...
    _abc_impl: ClassVar[_abc_data] = ...
    def __init__(self, value: Sequence | dict, callables: MapCallables) -> None: ...
    def __getitem__(self, index: Any) -> Any: ...
    def __len__(self) -> int: ...

class MapXComArg(XComArg):
    def __init__(self, arg: XComArg, callables: MapCallables) -> None: ...
    def iter_references(self) -> Iterator[tuple[Operator, str]]: ...
    def map(self, f: Callable[[Any], Any]) -> MapXComArg: ...
    def get_task_map_length(self, run_id: str) -> int | None: ...
    def resolve(self, *args, **kwargs) -> Any: ...

class _ZipResult(collections.abc.Sequence, typing.Generic):
    __orig_bases__: ClassVar[tuple] = ...
    __parameters__: ClassVar[tuple] = ...
    __abstractmethods__: ClassVar[frozenset] = ...
    _abc_impl: ClassVar[_abc_data] = ...
    def __init__(self, values: Sequence[Sequence | dict]) -> None: ...
    def __getitem__(self, index: Any) -> Any: ...
    def __len__(self) -> int: ...

class ZipXComArg(XComArg):
    def __init__(self, args: Sequence[XComArg]) -> None: ...
    def iter_references(self) -> Iterator[tuple[Operator, str]]: ...
    def get_task_map_length(self, run_id: str) -> int | None: ...
    def resolve(self, *args, **kwargs) -> Any: ...
def serialize_xcom_arg(value: XComArg) -> dict[str, Any]: ...
def deserialize_xcom_arg(data: dict[str, Any], dag: DAG) -> XComArg: ...
