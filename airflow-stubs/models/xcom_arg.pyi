from _typeshed import Incomplete
from airflow.api_internal.internal_api_call import internal_api_call as internal_api_call
from airflow.exceptions import AirflowException as AirflowException, XComNotFound as XComNotFound
from airflow.models import MappedOperator as MappedOperator, TaskInstance as TaskInstance
from airflow.models.abstractoperator import AbstractOperator as AbstractOperator
from airflow.models.baseoperator import BaseOperator as BaseOperator
from airflow.models.dag import DAG as DAG
from airflow.models.operator import Operator as Operator
from airflow.models.taskmixin import DAGNode as DAGNode, DependencyMixin as DependencyMixin
from airflow.utils.context import Context as Context
from airflow.utils.db import exists_query as exists_query
from airflow.utils.edgemodifier import EdgeModifier as EdgeModifier
from airflow.utils.mixins import ResolveMixin as ResolveMixin
from airflow.utils.session import NEW_SESSION as NEW_SESSION, provide_session as provide_session
from airflow.utils.setup_teardown import SetupTeardownContext as SetupTeardownContext
from airflow.utils.state import State as State
from airflow.utils.trigger_rule import TriggerRule as TriggerRule
from airflow.utils.types import ArgNotSet as ArgNotSet, NOTSET as NOTSET
from airflow.utils.xcom import XCOM_RETURN_KEY as XCOM_RETURN_KEY
from sqlalchemy.orm import Session as Session
from typing import Any, Callable, Iterable, Iterator, Sequence, overload

MapCallables = Sequence[Callable[[Any], Any] | str]

class XComArg(ResolveMixin, DependencyMixin):
    @overload
    def __new__(cls, operator: Operator, key: str = ...) -> XComArg: ...
    @overload
    def __new__(cls) -> XComArg: ...
    @staticmethod
    def iter_xcom_references(arg: Any) -> Iterator[tuple[Operator, str]]: ...
    @staticmethod
    def apply_upstream_relationship(op: Operator, arg: Any): ...
    @property
    def roots(self) -> list[DAGNode]: ...
    @property
    def leaves(self) -> list[DAGNode]: ...
    def set_upstream(self, task_or_task_list: DependencyMixin | Sequence[DependencyMixin], edge_modifier: EdgeModifier | None = None): ...
    def set_downstream(self, task_or_task_list: DependencyMixin | Sequence[DependencyMixin], edge_modifier: EdgeModifier | None = None): ...
    def map(self, f: Callable[[Any], Any]) -> MapXComArg: ...
    def zip(self, *others: XComArg, fillvalue: Any = ...) -> ZipXComArg: ...
    def concat(self, *others: XComArg) -> ConcatXComArg: ...
    def get_task_map_length(self, run_id: str, *, session: Session) -> int | None: ...
    def resolve(self, context: Context, session: Session = ..., *, include_xcom: bool = True) -> Any: ...
    def __enter__(self): ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None) -> None: ...

class PlainXComArg(XComArg):
    operator: Incomplete
    key: Incomplete
    def __init__(self, operator: Operator, key: str = ...) -> None: ...
    def __eq__(self, other: Any) -> bool: ...
    def __getitem__(self, item: str) -> XComArg: ...
    def __iter__(self): ...
    @property
    def is_setup(self) -> bool: ...
    @is_setup.setter
    def is_setup(self, val: bool): ...
    @property
    def is_teardown(self) -> bool: ...
    @is_teardown.setter
    def is_teardown(self, val: bool): ...
    @property
    def on_failure_fail_dagrun(self) -> bool: ...
    @on_failure_fail_dagrun.setter
    def on_failure_fail_dagrun(self, val: bool): ...
    def as_setup(self) -> DependencyMixin: ...
    def as_teardown(self, *, setups: BaseOperator | Iterable[BaseOperator] | ArgNotSet = ..., on_failure_fail_dagrun=...): ...
    def iter_references(self) -> Iterator[tuple[Operator, str]]: ...
    def map(self, f: Callable[[Any], Any]) -> MapXComArg: ...
    def zip(self, *others: XComArg, fillvalue: Any = ...) -> ZipXComArg: ...
    def concat(self, *others: XComArg) -> ConcatXComArg: ...
    def get_task_map_length(self, run_id: str, *, session: Session) -> int | None: ...
    def resolve(self, context: Context, session: Session = ..., *, include_xcom: bool = True) -> Any: ...

class _MapResult(Sequence):
    value: Incomplete
    callables: Incomplete
    def __init__(self, value: Sequence | dict, callables: MapCallables) -> None: ...
    def __getitem__(self, index: Any) -> Any: ...
    def __len__(self) -> int: ...

class MapXComArg(XComArg):
    arg: Incomplete
    callables: Incomplete
    def __init__(self, arg: XComArg, callables: MapCallables) -> None: ...
    def iter_references(self) -> Iterator[tuple[Operator, str]]: ...
    def map(self, f: Callable[[Any], Any]) -> MapXComArg: ...
    def get_task_map_length(self, run_id: str, *, session: Session) -> int | None: ...
    def resolve(self, context: Context, session: Session = ..., *, include_xcom: bool = True) -> Any: ...

class _ZipResult(Sequence):
    values: Incomplete
    fillvalue: Incomplete
    def __init__(self, values: Sequence[Sequence | dict], *, fillvalue: Any = ...) -> None: ...
    def __getitem__(self, index: Any) -> Any: ...
    def __len__(self) -> int: ...

class ZipXComArg(XComArg):
    args: Incomplete
    fillvalue: Incomplete
    def __init__(self, args: Sequence[XComArg], *, fillvalue: Any = ...) -> None: ...
    def iter_references(self) -> Iterator[tuple[Operator, str]]: ...
    def get_task_map_length(self, run_id: str, *, session: Session) -> int | None: ...
    def resolve(self, context: Context, session: Session = ..., *, include_xcom: bool = True) -> Any: ...

class _ConcatResult(Sequence):
    values: Incomplete
    def __init__(self, values: Sequence[Sequence | dict]) -> None: ...
    def __getitem__(self, index: Any) -> Any: ...
    def __len__(self) -> int: ...

class ConcatXComArg(XComArg):
    args: Incomplete
    def __init__(self, args: Sequence[XComArg]) -> None: ...
    def iter_references(self) -> Iterator[tuple[Operator, str]]: ...
    def concat(self, *others: XComArg) -> ConcatXComArg: ...
    def get_task_map_length(self, run_id: str, *, session: Session) -> int | None: ...
    def resolve(self, context: Context, session: Session = ..., *, include_xcom: bool = True) -> Any: ...

def serialize_xcom_arg(value: XComArg) -> dict[str, Any]: ...
def deserialize_xcom_arg(data: dict[str, Any], dag: DAG) -> XComArg: ...
