import abc
import airflow.models.abstractoperator
import airflow.utils.timezone as timezone
import collections.abc
import datetime
import jinja2
import typing
from _typeshed import Incomplete
from airflow.configuration import conf as conf
from airflow.exceptions import AirflowException as AirflowException, FailStopDagInvalidTriggerRule as FailStopDagInvalidTriggerRule, RemovedInAirflow3Warning as RemovedInAirflow3Warning, TaskDeferralError as TaskDeferralError, TaskDeferred as TaskDeferred
from airflow.lineage import apply_lineage as apply_lineage, prepare_lineage as prepare_lineage
from airflow.models.abstractoperator import AbstractOperator as AbstractOperator
from airflow.models.mappedoperator import OperatorPartial as OperatorPartial, validate_mapping_kwargs as validate_mapping_kwargs
from airflow.models.param import ParamsDict as ParamsDict
from airflow.models.pool import Pool as Pool
from airflow.models.taskinstance import TaskInstance as TaskInstance, clear_task_instances as clear_task_instances
from airflow.models.taskmixin import DependencyMixin as DependencyMixin
from airflow.serialization.enums import DagAttributeTypes as DagAttributeTypes
from airflow.ti_deps.deps.not_in_retry_period_dep import NotInRetryPeriodDep as NotInRetryPeriodDep
from airflow.ti_deps.deps.not_previously_skipped_dep import NotPreviouslySkippedDep as NotPreviouslySkippedDep
from airflow.ti_deps.deps.prev_dagrun_dep import PrevDagrunDep as PrevDagrunDep
from airflow.ti_deps.deps.trigger_rule_dep import TriggerRuleDep as TriggerRuleDep
from airflow.utils.context import Context as Context
from airflow.utils.decorators import fixup_decorator_warning_stack as fixup_decorator_warning_stack, warnings as warnings
from airflow.utils.edgemodifier import EdgeModifier as EdgeModifier
from airflow.utils.helpers import validate_key as validate_key
from airflow.utils.operator_resources import Resources as Resources
from airflow.utils.session import provide_session as provide_session
from airflow.utils.setup_teardown import SetupTeardownContext as SetupTeardownContext
from airflow.utils.trigger_rule import DEFAULT_TRIGGER_RULE as DEFAULT_TRIGGER_RULE, TriggerRule as TriggerRule
from airflow.utils.types import NOTSET as NOTSET
from airflow.utils.weight_rule import DEFAULT_WEIGHT_RULE as DEFAULT_WEIGHT_RULE, WeightRule as WeightRule
from datetime import timedelta
from typing import Any, Callable, ClassVar, Iterable, Sequence

TYPE_CHECKING: bool
DEFAULT_IGNORE_FIRST_DEPENDS_ON_PAST: bool
DEFAULT_OWNER: str
DEFAULT_POOL_SLOTS: int
DEFAULT_PRIORITY_WEIGHT: int
DEFAULT_QUEUE: str
DEFAULT_RETRIES: int
DEFAULT_RETRY_DELAY: datetime.timedelta
DEFAULT_TASK_EXECUTION_TIMEOUT: None
DEFAULT_WAIT_FOR_PAST_DEPENDS_BEFORE_SKIPPING: bool
NEW_SESSION: None
XCOM_RETURN_KEY: str
T: typing.TypeVar
def parse_retries(retries: Any) -> int | None: ...
def coerce_timedelta(value: float | timedelta) -> timedelta: ...
def coerce_resources(resources: dict[str, Any] | None) -> Resources | None: ...
def get_merged_defaults(dag: DAG | None, task_group: TaskGroup | None, task_params: collections.abc.MutableMapping | None, task_default_args: dict | None) -> tuple[dict, ParamsDict]: ...

class _PartialDescriptor:
    class_method: ClassVar[None] = ...
    def __get__(self, obj: BaseOperator, cls: type[BaseOperator] | None = ...) -> Callable[..., OperatorPartial]: ...
def partial(operator_class: type[BaseOperator], **kwargs) -> OperatorPartial: ...

class BaseOperatorMeta(abc.ABCMeta):
    @classmethod
    def __init__(cls, name, bases, namespace, **kwargs) -> None: ...

class BaseOperator(airflow.models.abstractoperator.AbstractOperator):
    template_fields: ClassVar[tuple] = ...
    template_ext: ClassVar[tuple] = ...
    template_fields_renderers: ClassVar[dict] = ...
    ui_color: ClassVar[str] = ...
    ui_fgcolor: ClassVar[str] = ...
    pool: ClassVar[str] = ...
    _base_operator_shallow_copy_attrs: ClassVar[tuple] = ...
    shallow_copy_attrs: ClassVar[tuple] = ...
    operator_extra_links: ClassVar[tuple] = ...
    _BaseOperator__serialized_fields: ClassVar[None] = ...
    _comps: ClassVar[set] = ...
    supports_lineage: ClassVar[bool] = ...
    _BaseOperator__instantiated: ClassVar[bool] = ...
    _lock_for_execution: ClassVar[bool] = ...
    _dag: ClassVar[None] = ...
    task_group: ClassVar[None] = ...
    subdag: ClassVar[None] = ...
    start_date: ClassVar[None] = ...
    end_date: ClassVar[None] = ...
    _BaseOperator__from_mapped: ClassVar[bool] = ...
    deps: ClassVar[frozenset] = ...
    __abstractmethods__: ClassVar[frozenset] = ...
    _abc_impl: ClassVar[_abc_data] = ...
    dag: Incomplete
    is_setup: Incomplete
    is_teardown: Incomplete
    @classmethod
    def partial(cls, operator_class: type[BaseOperator], **kwargs) -> OperatorPartial: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    def __or__(self, other): ...
    def __gt__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __setattr__(self, key, value): ...
    def add_inlets(self, inlets: Iterable[Any]): ...
    def add_outlets(self, outlets: Iterable[Any]): ...
    def get_inlet_defs(self): ...
    def get_outlet_defs(self): ...
    def get_dag(self) -> DAG | None: ...
    def has_dag(self): ...
    def prepare_for_execution(self) -> BaseOperator: ...
    def set_xcomargs_dependencies(self) -> None: ...
    def pre_execute(self, context: Any, *args, **kwargs): ...
    def execute(self, context: Context) -> Any: ...
    def post_execute(self, context: Any, *args, **kwargs): ...
    def on_kill(self) -> None: ...
    def __deepcopy__(self, memo): ...
    def render_template_fields(self, context: Context, jinja_env: jinja2.Environment | None = ...) -> None: ...
    def clear(self, *args, **kwargs): ...
    def get_task_instances(self, *args, **kwargs) -> list[TaskInstance]: ...
    def run(self, *args, **kwargs) -> None: ...
    def dry_run(self) -> None: ...
    def get_direct_relatives(self, upstream: bool = ...) -> Iterable[Operator]: ...
    @staticmethod
    def xcom_push(context: Any, key: str, value: Any, execution_date: datetime | None = ...) -> None: ...
    @staticmethod
    def xcom_pull(*args, **kwargs) -> Any: ...
    @classmethod
    def get_serialized_fields(cls): ...
    def serialize_for_task_group(self) -> tuple[DagAttributeTypes, Any]: ...
    def defer(self): ...
    def resume_execution(self, next_method: str, next_kwargs: dict[str, Any] | None, context: Context): ...
    def unmap(self, resolve: None | dict[str, Any] | tuple[Context, Session]) -> BaseOperator: ...
    def __le__(self, other, NotImplemented: NotImplementedType = ...) -> bool: ...
    def __ge__(self, other, NotImplemented: NotImplementedType = ...) -> bool: ...
    @property
    def operator_class(self): ...
    @property
    def task_type(self): ...
    @property
    def operator_name(self): ...
    @property
    def roots(self): ...
    @property
    def leaves(self): ...
    @property
    def output(self): ...
    @property
    def inherits_from_empty_operator(self): ...
def chain(*tasks: DependencyMixin | Sequence[DependencyMixin]) -> None: ...
def cross_downstream(from_tasks: Sequence[DependencyMixin], to_tasks: DependencyMixin | Sequence[DependencyMixin]): ...
def chain_linear(*elements: DependencyMixin | Sequence[DependencyMixin]): ...
def __getattr__(name): ...
