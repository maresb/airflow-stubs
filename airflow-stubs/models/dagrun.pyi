import airflow.settings as settings
import airflow.utils.log.logging_mixin
import airflow.utils.timezone as timezone
import airflow.utils.types
import sqlalchemy.ext.associationproxy
import sqlalchemy.orm.decl_api
import sqlalchemy.orm.instrumentation
import sqlalchemy.orm.mapper
import sqlalchemy.sql.schema
from _typeshed import Incomplete
from airflow.api_internal.internal_api_call import internal_api_call as internal_api_call
from airflow.callbacks.callback_requests import DagCallbackRequest as DagCallbackRequest
from airflow.configuration import airflow_conf as airflow_conf
from airflow.exceptions import AirflowException as AirflowException, RemovedInAirflow3Warning as RemovedInAirflow3Warning, TaskNotFound as TaskNotFound
from airflow.listeners.listener import get_listener_manager as get_listener_manager
from airflow.models.abstractoperator import NotMapped as NotMapped
from airflow.models.base import StringID as StringID
from airflow.models.expandinput import NotFullyPopulated as NotFullyPopulated
from airflow.models.taskinstance import TI as TI
from airflow.models.tasklog import LogTemplate as LogTemplate
from airflow.stats import Stats as Stats
from airflow.ti_deps.dep_context import DepContext as DepContext
from airflow.utils.helpers import chunks as chunks, is_container as is_container, prune_dict as prune_dict
from airflow.utils.log.logging_mixin import LoggingMixin as LoggingMixin
from airflow.utils.session import provide_session as provide_session
from airflow.utils.sqlalchemy import UtcDateTime as UtcDateTime, nulls_first as nulls_first, skip_locked as skip_locked, tuple_in_condition as tuple_in_condition, with_row_locks as with_row_locks
from airflow.utils.state import DagRunState as DagRunState, State as State, TaskInstanceState as TaskInstanceState
from airflow.utils.types import DagRunType as DagRunType, NOTSET as NOTSET
from typing import ClassVar

TYPE_CHECKING: bool
SCHEDULEABLE_STATES: set
NEW_SESSION: None
RUN_ID_REGEX: str

class TISchedulingDecision(tuple):
    _fields: ClassVar[tuple] = ...
    _field_defaults: ClassVar[dict] = ...
    _fields_defaults: ClassVar[dict] = ...
    _field_types: ClassVar[dict] = ...
    tis: Incomplete
    schedulable_tis: Incomplete
    changed_tis: Incomplete
    unfinished_tis: Incomplete
    finished_tis: Incomplete
    def __init__(self, _cls, tis: list[TI], schedulable_tis: list[TI], changed_tis: bool, unfinished_tis: list[TI], finished_tis: list[TI]) -> None: ...
    def __getnewargs__(self): ...

class DagRun(sqlalchemy.orm.decl_api.Base, airflow.utils.log.logging_mixin.LoggingMixin):
    __tablename__: ClassVar[str] = ...
    dag: ClassVar[None] = ...
    __table_args__: ClassVar[tuple] = ...
    DEFAULT_DAGRUNS_TO_EXAMINE: ClassVar[int] = ...
    _sa_class_manager: ClassVar[sqlalchemy.orm.instrumentation.ClassManager] = ...
    __table__: ClassVar[sqlalchemy.sql.schema.Table] = ...
    __mapper__: ClassVar[sqlalchemy.orm.mapper.Mapper] = ...
    _AssociationProxy_dag_run_note_139659710229136_inst: ClassVar[sqlalchemy.ext.associationproxy.ColumnAssociationProxyInstance] = ...
    id: Incomplete
    dag_id: Incomplete
    queued_at: Incomplete
    execution_date: Incomplete
    start_date: Incomplete
    end_date: Incomplete
    run_id: Incomplete
    creating_job_id: Incomplete
    external_trigger: Incomplete
    run_type: Incomplete
    conf: Incomplete
    data_interval_start: Incomplete
    data_interval_end: Incomplete
    last_scheduling_decision: Incomplete
    dag_hash: Incomplete
    log_template_id: Incomplete
    updated_at: Incomplete
    clear_number: Incomplete
    task_instances: Incomplete
    dag_model: Incomplete
    dag_run_note: Incomplete
    note: Incomplete
    state: Incomplete
    consumed_dataset_events: Incomplete
    creating_job: Incomplete
    serialized_dag: Incomplete
    def __init__(self, dag_id: Incomplete | None = ..., run_id: Incomplete | None = ..., queued_at: airflow.utils.types.ArgNotSet = ..., execution_date: Incomplete | None = ..., start_date: Incomplete | None = ..., external_trigger: Incomplete | None = ..., conf: Incomplete | None = ..., state: Incomplete | None = ..., run_type: Incomplete | None = ..., dag_hash: Incomplete | None = ..., creating_job_id: Incomplete | None = ..., data_interval: Incomplete | None = ...) -> None: ...
    def validate_run_id(self, key: str, run_id: str) -> str | None: ...
    def get_state(self): ...
    def set_state(self, state: DagRunState) -> None: ...
    def refresh_from_db(self, *args, **kwargs) -> None: ...
    @classmethod
    def active_runs_of_dags(cls, *args, **kwargs) -> dict[str, int]: ...
    @classmethod
    def next_dagruns_to_examine(cls, state: DagRunState, session: Session, max_number: int | None = ...) -> Query: ...
    @classmethod
    def find(cls, *args, **kwargs) -> list[DagRun]: ...
    @classmethod
    def find_duplicate(cls, *args, **kwargs) -> DagRun | None: ...
    @staticmethod
    def generate_run_id(run_type: DagRunType, execution_date: datetime) -> str: ...
    @staticmethod
    def fetch_task_instances(*args, **kwargs) -> list[TI]: ...
    def get_task_instances(self, *args, **kwargs) -> list[TI]: ...
    def get_task_instance(self, *args, **kwargs) -> TI | TaskInstancePydantic | None: ...
    @staticmethod
    def fetch_task_instance(*args, **kwargs) -> TI | TaskInstancePydantic | None: ...
    def get_dag(self) -> DAG: ...
    @staticmethod
    def get_previous_dagrun(*args, **kwargs) -> DagRun | None: ...
    @staticmethod
    def get_previous_scheduled_dagrun(*args, **kwargs) -> DagRun | None: ...
    def update_state(self, *args, **kwargs) -> tuple[list[TI], DagCallbackRequest | None]: ...
    def task_instance_scheduling_decisions(self, *args, **kwargs) -> TISchedulingDecision: ...
    def notify_dagrun_state_changed(self, msg: str = ...): ...
    def verify_integrity(self, *args, **kwargs) -> None: ...
    @staticmethod
    def get_run(session: Session, dag_id: str, execution_date: datetime) -> DagRun | None: ...
    @classmethod
    def get_latest_runs(cls, *args, **kwargs) -> list[DagRun]: ...
    def schedule_tis(self, *args, **kwargs) -> int: ...
    def get_log_template(self, *args, **kwargs) -> LogTemplate | LogTemplatePydantic: ...
    def get_log_filename_template(self, *args, **kwargs) -> str: ...
    @property
    def stats_tags(self): ...
    @property
    def logical_date(self): ...
    @property
    def is_backfill(self): ...

class DagRunNote(sqlalchemy.orm.decl_api.Base):
    __tablename__: ClassVar[str] = ...
    __table_args__: ClassVar[tuple] = ...
    _sa_class_manager: ClassVar[sqlalchemy.orm.instrumentation.ClassManager] = ...
    __table__: ClassVar[sqlalchemy.sql.schema.Table] = ...
    __mapper__: ClassVar[sqlalchemy.orm.mapper.Mapper] = ...
    user_id: Incomplete
    dag_run_id: Incomplete
    content: Incomplete
    created_at: Incomplete
    updated_at: Incomplete
    dag_run: Incomplete
    def __init__(self, content, user_id: Incomplete | None = ...) -> None: ...
